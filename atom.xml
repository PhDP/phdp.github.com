<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Philippe Desjardins-Proulx -- Posts</title>
    <link href="http://phdp.github.io//atom.xml" rel="self" />
    <link href="http://phdp.github.io/" />
    <id>http://phdp.github.io//atom.xml</id>
    <author>
        <name>Philippe Desjardins-Proulx</name>
        <email>philippe.d.proulx@gmail.com</email>
    </author>
    <updated>2015-04-05T00:00:00Z</updated>
    <entry>
    <title>Automated reasoning in F#, Scala, Haskell, C++, and Julia</title>
    <link href="http://phdp.github.io//posts/2015-04-05-automated-reasoning.html" />
    <id>http://phdp.github.io//posts/2015-04-05-automated-reasoning.html</id>
    <published>2015-04-05T00:00:00Z</published>
    <updated>2015-04-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Automated reasoning in F#, Scala, Haskell, C++, and Julia</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="Automated reasoning in F#, Scala, Haskell, C++, and Julia" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2015.04.05</p>
<p>We need to simplify the following expression:</p>

\[e = ((1 + 0 \times x) \times 3) + 12.\]

<p>Luckily for us, we won't have to remember any elementary school arithmetic,
because Harris' excellent <a
  href='http://www.cambridge.org/ca/academic/subjects/computer-science/programming-languages-and-applied-logic/handbook-practical-logic-and-automated-reasoning'>
  <i>Handbook of Practical Logic and Automated Reasoning</i></a> begins with a
simple algorithm to do exactly that. It's not complicated, but it's a pretty
good barometer of how painful a programming language will be for the kind of
hybrid (probabilistic logic, or statistical relational) approaches I work with.
Here, I compare the implementations of Harris' simple algorithm in F#, Scala,
Haskell, C++, and Julia.</p>

<p>No programming languages were hurt while writing this post. It's not a
competition, and I avoided talking about languages I dislike. Sum types are
discussed in length because they are awesome and useful for this problem
(and many, many others).</p>

<h2>The ML family</h2>

<p>Harris' book uses OCaml, a popular language for solvers. F#, Haskell, and
Scala all share roots with OCaml, with F# being the closest thing to an OCaml
dialect. I'll start with F#:</p>

<pre><code class="fsharp">/// A sum type for the expression.
/// An expression is either a var (which is a string), a constant
/// (which is an integer), an addition (made of two expressions)
/// or a multiplication (also made of two expressions).
type Expr =
    | Var of string
    | Const of int
    | Add of Expr * Expr
    | Mul of Expr * Expr

/// Simplify a single component of the expression. This function
/// takes an expression and use pattern matching to select the
/// right approach based on type and value. For example, if we
/// add a constant 0 to some x (which can be expression), then
/// we return x.
let simplify1 e =
    match e with
    | Add (Const 0, x)
    | Add (x, Const 0)
    | Mul (x, Const 1)
    | Mul (Const 1, x)        -> x
    | Mul (x, Const 0)
    | Mul (Const 0, x)        -> Const 0
    | Add (Const a, Const b)  -> Const (a + b)
    | Mul (Const a, Const b)  -> Const (a * b)
    | _                       -> e

/// Recursive function to simplify an entire expression.
let rec simplify e =
    match e with
    | Add (x, y) -> Add (simplify x, simplify y)
    | Mul (x, y) -> Mul (simplify x, simplify y)
    | _          -> e
    |> simplify1

/// Return the value string if the expression can be reduced to a constant.
let exprStr e =
    match e with
    | Const x -> string x
    | _       -> "The expression could not be simplified to a constant."

/// The |> operator sends the result on its left to its right, for example
/// "5.0 |> log |> sqrt" computes log(5.0) and then the square root of the
/// result. This is nice because it allows a more natural left-to-right
/// flow for functional programming.
[&lt;EntryPoint>]
let main argv =
    Add (Mul (Add (Const 1, Mul (Const 0, Var "x")), Const 3), Const 12)
    |> simplify
    |> exprStr
    |> printf "%s"
    0 /// F#'s main returns 0 for success Ã  la C
</code></pre>

<p>It's almost the same as the OCaml version in Harris' book. The key trick is
to define an expression (Expr) as a variable (string) <b>or</b> a constant
(integer) <b>or</b> an addition <b>or</b> a multiplication (both made of two
expressions). The <b>or</b> is important, object-oriented programming languages
focuses on hierarchies of objects, while sum types define a type as a series of
alternatives. Sum types are important for another reason: they provide
an easy way to express things like "this function <i>might</i> return
an integer", for example in Haskell if we want a data structure that maps
keys to values:</p>

<pre><code class="haskell">data Expr =
import Data.Map (Map)
import qualified Data.Map as Map

capitals = Map.fromList [("Finland", "Helsinski"), ("France", "Paris"),
  ("Japan", "Tokyo"), ("South Korea", "Seoul"), ("Arrakis", "Arrakeen")]

lookupCapitals country = case Map.lookup country capitals of
  Just capital -> "The capital of " ++ country ++ " is " ++ capital ++ "."
  Nothing      -> "Is " ++ country ++ " even a country?"
</code></pre>

<p>The point is that a key-value store will only return a value if the key is
present. In this example, the map takes a country (string) and return its
capital (string). However, when we try to take a value from the map with the
lookup function, Haskell returns a <b>Maybe</b> type with either <b>Just
String</b>, if the string provided is found in the map, or <b>Nothing</b> if
the key was absent. We then use pattern matching to deal with these
possibilities in the lookupCapitals function. One of the most common mistake in
programming is to return a null and not deal with it properly. The solution
with sum types is to return a wrapped value and handling possibilities
explicitly with pattern matching. It solves with types what many languages
would solve with exceptions and try-catch apparatuses.</p>

<pre><code class="haskell">ghci> lookupCapitals "Arrakis"
"The capital of Arrakis is Arrakeen."
ghci> lookupCapitals "Canada"
"Is Canada even a country?"</code></pre>

<p>Speaking of Haskell, the code for the algorithm is:</p>

<pre><code class="haskell">data Expr =
    Var String
  | Const Int
  | Add Expr Expr
  | Mult Expr Expr

simplify1 :: Expr -> Expr
simplify1 e = case e of
  Add (Const 0) x           -> x
  Add x (Const 0)           -> x
  Add (Const a) (Const b)   -> Const $ a + b
  Mult x (Const 0)          -> Const 0
  Mult (Const 0) x          -> Const 0
  Mult x (Const 1)          -> x
  Mult (Const 1) x          -> x
  Mult (Const a) (Const b)  -> Const $ a * b
  _                         -> e

simplify :: Expr -> Expr
simplify e = case e of
  Add x y   -> simplify1 $ Add (simplify x) (simplify y)
  Mult x y  -> simplify1 $ Mult (simplify x) (simplify y)
  _         -> simplify1 e

e = Add (Mult (Add (Const 1) (Mult (Const 0) (Var "x"))) (Const 3)) (Const 12)
s = simplify e

main = putStrLn $ case s of
  Const x -> show x
  _ -> "Could not simplify the expression to a constant."
</code></pre>

<p>It's quite similar to F#. I decided to add types explicitly to
<i>simplify1</i> and <i>simplify</i>, but Haskell is smart enough to deduce the
type without this. Arguably the only thing worth explaining is the $ operator.
The operator forces Haskell to evaluate the expression to the right of the
operator in priority, and if it reminds you of parentheses, you are absolutely
right. <i>x</i> and <i>y</i> have the same value here:</p>

<pre><code class="haskell">x = log (sqrt (exp 5.0))
y = log $ sqrt $ exp 5.0
</code></pre>

<p>The operator is there to reduce visual clutter. In my opinion, F# is easier
to read because the |> operator enforces left-to-right reading, which is more
natural than reading code inside-out:</p>

<pre><code class="fsharp">
z = exp 5.0 |> sqrt |> log
</code></pre>

<p>And now for something a bit different: Scala. It's also a static
functional programming language with sum types, but its greater
integration with the object-oriented paradigm is evident:</p>

<pre><code class="scala">object Simplify {
  sealed abstract class Expr { override def toString = show(this) }
  case class Variable(name: String) extends Expr
  case class Const(value: Int) extends Expr
  case class Add(left: Expr, right: Expr) extends Expr
  case class Mult(left: Expr, right: Expr) extends Expr

  def evalOne(e: Expr): Expr = e match {
    case Add(Const(0), r)         => r
    case Add(l, Const(0))         => l
    case Add(Const(a), Const(b))  => Const(a + b)
    case Mult(Const(0), r)        => Const(0)
    case Mult(l, Const(0))        => Const(0)
    case Mult(Const(1), r)        => r
    case Mult(l, Const(1))        => l
    case Mult(Const(a), Const(b)) => Const(a * b)
    case _                        => e
  }

  def eval(e: Expr): Expr = e match {
    case Add(l, r)  => evalOne(Add(eval(l), eval(r)))
    case Mult(l, r) => evalOne(Mult(eval(l), eval(r)))
    case _          => e
  }

  def show(e: Expr) = e match {
    case Const(x) => print(x)
    case _        =>
      print("The expression could not be simplified to a constant.")
  }

  def main(args: Array[String]) {
    var e = Add(Mult(Add(Const(1), Mult(Const(0), Variable("x"))),
              Const(3)), Const(12))
    var s = eval(e)
    print(s)
  }
}
</code></pre>

<p>Everything is an object in Scala. Thus, we have to define the functions to
simplify as methods inside a singleton object. I named the functions
<i>evalOne</i> and <i>eval</i> since it has a bit odd to have a function named
<i>simplify</i> inside a Simplify object.</p>

<h2>C++</h2>

<p>Few understand every corner of C++'s monstrous standard. It's huge.
Surely, with so many features, it must be easy to solve this problem in C++.
Well no, it's not. This is a well-known
issue with C++, see <a href="https://parasol.tamu.edu/~yuriys/pm/"><i>Open
and Efficient Type Switch for C++</i></a> for an efficient solution
using a pattern matching library (the effort is directed by the creator
of the C++ language). That said, here I'll use the boost library (A)
because solutions based only on the standard library are contrived and
(B) because boost is almost standard.</p>

<pre><code class="cpp">#include &lt;iostream>
#include &lt;string>
#include &lt;boost/variant>

struct Add;
struct Mult;

using Expr = boost::variant<
  int,
  std::string,
  boost::recursive_wrapper&lt;Add>,
  boost::recursive_wrapper&lt;Mult>>;

struct Add {
  Expr left, right;
  Add(const Expr &left_, const Expr &right_) : left(left_), right(right_) {
  }
};

struct Mult {
  Expr left, right;
  Mult(const Expr &left_, const Expr &right_) : left(left_), right(right_) {
  }
};

struct add_visit : public boost::static_visitor&lt;Expr> {
  Expr operator()(int l, int r) const {
    return Expr(l + r);
  }
  template&lt;class X> Expr operator()(int l, const X &x) const {
    return l == 0? Expr(x) : Add(Expr(l), Expr(x));
  }
  template&lt;class X> Expr operator()(const X &x, int r) const {
    return r == 0? Expr(x) : Add(Expr(r), Expr(x));
  }
  template&lt;class X, class Y>
  Expr operator()(const X &x, const Y &y) const {
    return Add(Expr(x), Expr(y));
  }
};

struct mul_visit : public boost::static_visitor&lt;Expr> {
  Expr operator()(int l, int r) const {
    return Expr(l * r);
  }
  template&lt;class X> Expr operator()(int l, const X &x) const {
    return l == 0? Expr(0) : (l == 1? Expr(x) : Mult(Expr(l), Expr(x)));
  }
  template&lt;class X> Expr operator()(const X &x, int r) const {
    return r == 0? Expr(0) : (r == 1? Expr(x) : Mult(Expr(r), Expr(x)));
  }
  template&lt;class X, class Y>
  Expr operator()(const X &x, const Y &y) const {
    return Mult(Expr(x), Expr(y));
  }
};

struct simplify1 : public boost::static_visitor&lt;Expr> {
  Expr operator()(const Add &a) const {
    return boost::apply_visitor(add_visit(), a.left, a.right);
  }
  Expr operator()(const Mult &m) const {
    return boost::apply_visitor(mul_visit(), m.left, m.right);
  }
  template&lt;class X> Expr operator()(const X &x) const {
    return Expr(x);
  }
};

struct simplify : public boost::static_visitor&lt;Expr> {
  Expr operator()(const Add &a) const {
    auto left = boost::apply_visitor(simplify(), a.left);
    auto right = boost::apply_visitor(simplify(), a.right);
    auto add_lr = boost::apply_visitor(add_visit(), left, right);
    return boost::apply_visitor(simplify1(), add_lr);
  }
  Expr operator()(const Mult &m) const {
    auto left = boost::apply_visitor(simplify(), m.left);
    auto right = boost::apply_visitor(simplify(), m.right);
    auto mul_lr = boost::apply_visitor(mul_visit(), left, right);
    return boost::apply_visitor(simplify1(), mul_lr);
  }
  template&lt;class X> Expr operator()(const X &x) const {
    return x;
  }
};

struct print_expr : public boost::static_visitor&lt;std::string> {
  std::string operator()(int x) const { return std::to_string(x); };
  std::string operator()(const Expr &e) const {
    return "The expression could not be simplified to a constant.";
  };
};

int main() {
  auto e = Expr(Add(
      Expr(Mult(Expr(Add(Expr(1), Expr(Mult(Expr(0), Expr("x"))))),
      Expr(3))), Expr(12)));
  auto s = boost::apply_visitor(simplify(), e);
  std::cout << boost::apply_visitor(print_expr(), s) << std::endl;
  return 0;
}
</code></pre>

<p>So, this is boost::variant in action, and boost is anything but clever code.
My biggest qualm with this type of clever header-heavy code is that you get to
see a big chunk of the developers' lifework unroll before your eyes every time
you make a small mistake. Even LLVM/Clang will (probably) not save you.  It's
almost prohibitively verbose and a bit trickier to understand. If you want to
know how this code works, you need to read a bit on the visitor pattern.</p>

<p>C++ template metaprogramming is both awesome and terrifying. Mostly
terrifying.  I would not be surprised if someone were to find a simple way to
use C++11/C++14 features to build a small and nice matching library. <a
href='https://github.com/jbandela/simple_match'>This attempt</a> is halfway
there (with boost::variant, it might already allows matching on type but I have
yet to play with the idea). C++ is awesome for scientific computing, with tons
of awesome librairies, so I'd love to see a nicer solution to his problem.</p>

<h2>Julia</h2>

<p>Julia is an attempt to build a fast and flexible replacement for
R/Python/Matlab.  An issue with most dynamic languages is that there is no
elegant way to switch on type. Actually, you cannot really do it with most
static languages either, see previous section... However, Julia supports
multiple-dispatch based on type annotation. To be clear, it's quite different
from the F#/Scala/Haskell code.  In these languages, it is possible to define
sum types and do pattern matching on their constructor. With Julia, we define a
function with type annotation and let the interpreter dispatch based on runtime
type information. Multiple dispatch is supported in Julia for performance: it
allows the interpreter to compile optimized functions and use the best one,
adding predictability while keeping the language dynamic (for some reason...).
At first sight, it does work pretty well:</p>

<pre><code class="julia">abstract Expr

type Const <: Expr; val::Int end
type Var <: Expr; name::String end
type Add <: Expr; left::Expr; right::Expr end
type Mult <: Expr; left::Expr; right::Expr end

add(x::Const, y::Const) = Const(x.val + y.val)
add(x::Const, y::Expr) = x.val == 0? y : Add(x, y)
add(x::Expr, y::Const) = add(y, x)
add(x::Expr, y::Expr) = Add(x, y)

mult(x::Const, y::Const) = Const(x.val * y.val)
mult(x::Const, y::Expr) = x.val == 1? y : (x.val == 0? Const(0) : Mult(x, y))
mult(x::Expr, y::Const) = mult(y, x)
mult(x::Expr, y::Expr) = Mult(x, y)

simplify1(a::Add) = add(a.left, a.right)
simplify1(m::Mult) = mult(m.left, m.right)
simplify1(e::Expr) = e

simplify(a::Add) = simplify1(Add(simplify(a.left), simplify(a.right)))
simplify(m::Mult) = simplify1(Mult(simplify(m.left), simplify(m.right)))
simplify(e::Expr) = e

printExpr(c::Const) = print(c.val)
printExpr(e::Expr) =
  print("The expression could not be simplified to a constant.")

e = Add(Mult(Add(Const(1), Mult(Const(0), Var("x"))), Const(3)), Const(12))
s = simplify(e)
printExpr(s)
</code></pre>

<p>Unlike pattern matching, we can only dispatch on type, so we need an if
expression (the ? operator in Julia, just like C), or I could've used the match
macro, but it's overkill here. It's not too inelegant, and at first I thought
it was a good enough way to simulate sum types and pattern matching. It matters
to the Julia ecosystem because these features are very useful to build solvers,
logic and theorem proving systems, etc etc. Pretty useful for a technical 
computing platform. Unfortunately, while Julia does well with this simple example,
I think an oddity with the language would soon bite us: you can't type the
return value, and yes, it's big deal.</p>

<p>First, it's a issue for the sake of correctness: you can return a float
thinking you're returning an integer. Also, since annotation is not allowed for
the return value, it's also impossible to add annotation for a higher-order
function (a function taking functions as input). As a concrete example,
first-order logic has <i>predicates</i> mapping objects to a boolean, and <i>functions</i> mapping objects to objects. We'd like to do:</p>

<pre><code class="julia">solve(pre::(Object -> Bool), ...)

solve(fun::(Object -> Object), ...)
</code></pre>

<p>But instead, we'd have to test the type of the return value inside the
function. That said, Julia is young and <a
href='https://github.com/JuliaLang/julia/issues/1090'>it might get return type
declarations at some point.</a></p>

<h2>Conclusion</h2>

<p>Sum types are awesome.</p>



]]></summary>
</entry>
<entry>
    <title>Knowledge representation and species interactions</title>
    <link href="http://phdp.github.io//posts/2014-06-11-food-webs.html" />
    <id>http://phdp.github.io//posts/2014-06-11-food-webs.html</id>
    <published>2014-06-11T00:00:00Z</published>
    <updated>2014-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Knowledge representation and species interactions</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="Knowledge representation and species interactions" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2014.06.11</p>
<h2>The food web</h2>

<p>One of the most fascinating aspect of ecology is the complex web of
interactions between individuals (or populations, or species), and how it
shapes the structure of communities. But what is the best way to represent
these interactions?</p>

<p>The classical representation is a
directed network. <a href='http://mangal.uqar.ca/data/network/17/'>Here's
one from the mangal database</a> [2]. We can have predator-prey interactions,
parasitism, mutualism, competition, etc etc...</p>

<p>However, it's a somewhat limited representation. A good way to evaluate a
knowledge representation is to look at the possible queries. What questions
can be answered? What questions cannot be answered? How expressive can the
queries be? How expressive are the answers?</p>

<p>Despite their widespread use, these interactions networks can only answer
one question: is there a binary interaction between X and Y? The <i>binary
</i> part is important, because these networks cannot deal with indirect
relationships such as: X eats Y except when W is there.</p>

<p>It doesn't scale well either: two species might only interact in a given
region, a problem solved with distinct networks, but we would need distinct
networks for every region with distinct interactions and a lot of information
will be repeated.</p>

<h2>Going stochastic</h2>

<p>Instead of saying X eats Y, we could say X eats Y with probability Z.
Adopting a probabilistic perspective does solve quite a few issues. We can
now handle uncertainty and to some extent spatio-temporal variations. That
said, we still cannot handle indirect relationships, and it doesn't scale
that well.</p>

<p>For example, if species A and B compete on the west coast with probability
0.9 but only with probability 0.1 on the east coast, we would lose important
information by having a network say they compete with probability 0.5. Dividing
the network in two would improve our model's accuracy, but we are again getting
in the messy network-of-networks business.  </p>

<p>My supervisors, TimothÃ©e Poisot and Dominique Gravel, recently proposed a
metaweb concept that includes, among many other ideas, probabilistic links, but
in their case it's more than just adding probabilities to links [3].</p>

<h2>A unified path to unification</h2>

<p>To criticize an approach to ecology for missing some features is too easy.
All representations have limitations, and any approach to science relies on
some simplification of reality. However, in this case we can have our cake and
eat it too by looking at what is going on in the field of knowledge
representation (KR), which has been defined as [0]:</p>

<p><blockquote>[...] the scientific domain concerned with the study of
computational models able to explicitly represent knowledge by symbols and
to process these symbols in order to produce new ones representing other
pieces of knowledge. Systems built upon such computational models are called
knowledge-based systems. Their main components are a knowledge base and a
reasoning engine.</blockquote></p>

<p>To illustrate, let's look at two lizards: <i>P. cinereus</i> and <i>P.
hoffmani</i> [1]. The two species essentially hunt the same preys but, when
they are found in the same region, character displacement pushes them to
specialize on different preys. This fact cannot be easily express with
standard knowledge representations for food webs, but we can with a bit
of logic:</p>

\[presence(\mbox{cinereus}, r) \land presence(\mbox{hoffmani}, r) \Rightarrow eat(\mbox{cinereus}, A, r).\]

<p>The formula reads: the presence of cinereus in region \(r\) and the presence
of hoffmani in \(r\) implies that cinereus eats prey A in \(r\). Formulas like
this be seen as templates: presence(cinereus) will be either true or false at
any given place, but a probability is assigned to the entire formula so it can
be revised with new evidence [4]. This is an important point, it means we can
use the standard food webs as evidence to build these logical formulas, but we
still get a probabilistic model capable of handling uncertainty.</p>

<p>The formula is readable, can be used with modern inference tools, and is
very flexible, but there's better. What if the presence of cinereus in \(r\)
could be predicted with a few conditions, we could have something like
this:</p>

\[northAmerica(r) \land (presence(A, r) \lor presence(B, r)) \Rightarrow presence(\mbox{cinereus}, r).\]

<p>If the region \(r\) is in north America and if either species A or B are
present, then cinereus will be present. Again, this equation would be
assigned a probability. This is a simplistic model of presence/absence, but
the point is that this knowledge representation allows different formula to
be combined. Various evidence can be used together instead of having a wall
between ecological facts, and such database of probabilistic logical formula
supports sophisticated queries.</p>

<p>There are many discussions about having integrative frameworks and
theories in ecology. This is especially true for interaction networks, which
are often present in one form or another in ecology. Ironically, these
discussions of integration are often ignoring modern research in
other fields. Knowledge representation offers powerful tools with mature
software that are worth checking, especially if we want to understand
how different ideas and evidence can be combined.</p>

<h2>References</h2>

<p>[0] M Chein and M-L Mugnier. <i>Graph-based Knowledge Representation</i>. Springer, 2009.</p>

<p>[1] JB Losos. <a href='http://www.oeb.harvard.edu/faculty/losos/jblosos/pdfs/pnas.pdf'>Ecological character displacement and the study of adaptation</a>. PNAS, 2000.</p>

<p>[2] T Poisot, B Baiser, JA Dunne, S KÃ©fi, F Massol, N Mouquet, TN Romanuk, DB Stouffer, SA Wood, and D Gravel. <a href='http://dx.doi.org/10.1101/002634'>Mangal - making complex ecological network analysis simpler</a>. <i>bioRxiV</i>, 2014.</p>

<p>[3] T Poisot, DB Stouffer, and D Gravel. <a href='http://dx.doi.org/10.1101/001677'>Beyond species: why ecological interactions vary through space and time</a>. <i>bioRxiV</i>, 2014.</p>

<p>[4] M Richardson and P Domingos. Markov logic networks. <i>Machine Learning</i> <b>62</b> (1-2): 107â136, 2006.</p>


]]></summary>
</entry>
<entry>
    <title>Scriptoria.info - Tracking Science Manuscripts under Revision Control Systems</title>
    <link href="http://phdp.github.io//posts/2013-07-22-scriptopia.html" />
    <id>http://phdp.github.io//posts/2013-07-22-scriptopia.html</id>
    <published>2013-07-22T00:00:00Z</published>
    <updated>2013-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Scriptoria.info - Tracking Science Manuscripts under Revision Control Systems</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="Scriptoria.info - Tracking Science Manuscripts under Revision Control Systems" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2013.07.22</p>
<p><i><b>Update 2014-09-06</b>: I wanted Scriptoria to be a group effort,
something built by several scientists, especially since I never intended to
stay in academia after the Ph.D. I failed to create enough momentum around the
project, so I'm moving on...</i></p>

<p>There is widespread dissatisfaction with the way scientific publishing is
done, but fortunately many (cheaper) alternatives are emerging. Among these
alternatives is git (and revision control systems). Karthik Ram recently
wrote a piece on the use of git in science: <a href=
"http://www.scfbm.org/content/8/1/7/">http://www.scfbm.org/content/8/1/7/</a>.
Highly suggested reading.</p>

<p>The put it bluntly: revision control systems are more modern and
efficient than our peer-review system (my words, not his). With git and
github (a hosting service for git), <a href=
"https://github.com/PhDP/article_preprint/commits/master">changes are
tracked, with the full history of the document preserved in the repository
</a>. Collaborators can easily fork the repository of the manuscript, make
changes, and then push back the changes to a main repository.</p>

<p>Git was built to allow potentially thousands of developers to work on the
same code, create branches to test new ideas, and push back their changes
(if they want to merge everything into a single version). Better: websites
like <a href= "https://github.com/">GitHub</a>, <a href=
"https://bitbucket.org/">BitBucket</a>, <a href="https://code.google.com/">
Google Code</a>, Microsoft's <a href ="http://www.codeplex.com/">CodePlex</a>,
or <a href="http://gitorious.org/" >Gitorious</a> (itself an open source
project), allow the users to create open git repositories free of charge,
with wiki systems and bug tracking included.</p>

<p>Bug tracking is particularly great for science. Bug tracking systems are
essentially the software equivalent of asking a revision in a peer-review.
Found a problem with some paper? <a href=
"https://github.com/weecology/data-sharing-paper/issues/71"> Open a freaking
issue!</a> Open manuscripts and open reviews, all free, and all this thanks
to git, an open-source piece of software originally written for the Linux
kernel.</p>

<p>Git, and other similar systems, are potentially very disruptive and not
only for science, see <a href=
"http://www.ted.com/talks/clay_shirky_how_the_internet_will_one_day_transform_
government.html">Clay Shirky's great talk on the subject</a>. These systems
were built by software engineers with a great deal of experience on close
collaborations. Several scientists are already using git to write
manuscripts... the problem is, there is no way to search these manuscripts,
no way to know where they are.</p>

<p>Git et al. are decentralized and it's fine. Actually, I would rather not
have all scientific manuscripts at the same place. However, we need a tool
to track the manuscripts being developed on github, bitbucket, google code.
We need this tool both to browse these open manuscripts but also to create
incentives for scientists to push their manuscripts online as soon as
possible.</p>

<p>This is Scriptoria.info, a project to track manuscripts being written on
github, bitbucket, gitorious, and other hosting services git revision
control systems. The goal of Scriptoria is not to host repositories but
simply track them in the various hosting services, allow them to be search,
and offer a simple API. I see the project as a thin layer over an already
well-established system. Scriptoria is not ready (as of 2013.07.22), it's
just started! The code will be developed on <a href=
"https://github.com/PhDP/Scriptoria">github</a> and everyone is free to
contribute. <a href="https://twitter.com/recology_">Scott Chamberlain</a>
already suggested <a href= "https://github.com/PhDP/Scriptoria/issues/7">
(via an issue!)</a>
 a way to track the manuscripts...</p>


]]></summary>
</entry>
<entry>
    <title>Machine Learning and Deep Transfer Learning</title>
    <link href="http://phdp.github.io//posts/2013-07-05-dtl.html" />
    <id>http://phdp.github.io//posts/2013-07-05-dtl.html</id>
    <published>2013-07-05T00:00:00Z</published>
    <updated>2013-07-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Machine Learning and Deep Transfer Learning</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="Machine Learning and Deep Transfer Learning" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2013.07.05</p>
<p>This short text explains the basic idea behind deep
transfer learning, an ambitious attempt to build machine learning algorithms
capable of exploiting prior knowledge. If you're looking for a technical
treatment, I highly suggest Mihalkova's <a href=
"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.241&rep=rep1&typ
e=pdf">Mapping and Revising Markov Logic Networks for Transfer Learning</a>,
one of the best algorithm for deep transfer. Also, I do not dwell on
the distinctions between deep and shallow transfer, and the various subtypes
of machine learning algorithms (supervised vs nonsupervised, online vs
batch): I want to provide a strategic overview of what deep transfer learning
is about and why it's important.</p>

<h2>The standard approach to machine learning</h2>

<p>Machine learning is straightforward: data is fed to an algorithm that
builds a model and, hopefully, generate good predictions:</p>

<div class="imagecenter">
  <img src="../images/ml-900.png" alt="Machine learning">
</div>

<p>The data can be pretty much anything from ecological data to movie
preferences. Machine learning algorithms can build effective models because
they are tailored for the input data. It is hard, if not impossible, to
build by hand the right mathematical model to solve complex problems such as
handwriting recognition, spam detection, language processing and many, many,
other problems where no simple equation can be found. In these cases, we
have to step back and, instead of focusing on building the model ourselves,
we design algorithms to do it in our place. That's the essence of machine
learning. This approach has been incredibly powerful to solve a wide array
of difficult problems in pretty much all fields of inquiry: it's the <a href=
"http://www.csee.wvu.edu/~gidoretto/courses/2011-fall-cp/reading/TheUnreasonable%20EffectivenessofData_IEEE_IS2009.pdf">
unreasonable effectiveness of data.</a></p>

<p>Building models this way is good, but it has a few problems. What can we
do when we have little data? If the situation has changed since we collected
our data, is our model still good? When we face a similar situation, can we
reuse our previous model or do we need to build a new one?</p>

<h2>Deep transfer learning algorithms</h2>

<p>Machine learning algorithms use a <i>Tabula rasa</i> approach: the
algorithms start with nothing and build the model only with the supplied
data. It's simple, but it's also inefficient. Deep transfer learning is
about transferring knowledge between different tasks. Instead of starting
from scratch, deep transfer algorithms can exploit accumulated knowledge to
learn faster (we also have good reasons to think deep transfer is a key
component to build reliable models, but that's a more complicated topic). It
looks like this:</p>

<div class="imagecenter">
  <img src="../images/ml-transfer-900.png" alt="Deep transfer learning">
</div>

<p>The algorithm, instead of simply reading the input data, will exploit
data from a large data-set of prior knowledge. This, in itself, is tricky.
The algorithm must make a judgment call: what is relevant to the present
subject, what can be used, and what should be discarded? Certainly, our
model for US presidential elections will be awful if we try, say, <a href=
"http://en.wikipedia.org/wiki/Redskins_Rule">to bring data from football
games</a>. So there are risks to deep transfer learning, but the benefits
are huge.</p>

<p>To make an analogy with human learning, imagine you need to learn to run.
Of course, running is very similar to walking so you won't start from zero.
You're able to see that running and walking are similar tasks and thus you
can transfer your knowledge of walking into running. It allows you to learn
much faster, and also yield interesting information on how the two tasks are
related to each other. If you need to learn Mandarin though, running and
walking won't serve you. It's a more general approach: a very conservative
deep transfer learning algorithm could choose to always reject prior
information and would build the model just as before.</p>

<p>Machine learning starts from 0. Big data is nice, but it would be
much nicer if we could build models with more than a tiny fraction of it.
Deep transfer is about determining what is relevant in previous data-sets
and use this information to design better models, and faster! My thesis
focuses on doing just that, using the complex heterogeneous data-sets
found in ecology.</p>


]]></summary>
</entry>
<entry>
    <title>The case for open preprints in biology</title>
    <link href="http://phdp.github.io//posts/2013-05-14-case-preprint.html" />
    <id>http://phdp.github.io//posts/2013-05-14-case-preprint.html</id>
    <published>2013-05-14T00:00:00Z</published>
    <updated>2013-05-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>The case for open preprints in biology</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="The case for open preprints in biology" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2013.05.14</p>
  <p>Initiated by a <a href="http://jabberwocky.weecology.org/2012/07/18/esa-journals-do-not-allow-papers-with-preprints/">simple tweet</a>, 
  this collaboration on preprints in biology was ultimately accepted in PLOS Biology. The whole writing
  process was done on GitHub (<a href="https://github.com/PhDP/article_preprint">here's the repo</a>).</p>

  <h2>Reference</h2>

  <p><b>P Desjardins-Proulx</b>, EP White, JJ Adamson, K Ram, T Poisot, and D
Gravel. The case for open preprints in biology. <i>PLOS Biology</i> 11(5): e1001563, 2013.
<a href="http://www.plosbiology.org/article/info%3Adoi%2F10.1371%2Fjournal.pbio.1001563">[URL]</a>
</p>


]]></summary>
</entry>
<entry>
    <title>Evolution of a transposon in Daphnia hybrid genomes</title>
    <link href="http://phdp.github.io//posts/2013-02-06-transposon.html" />
    <id>http://phdp.github.io//posts/2013-02-06-transposon.html</id>
    <published>2013-02-06T00:00:00Z</published>
    <updated>2013-02-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Evolution of a transposon in Daphnia hybrid genomes</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="Evolution of a transposon in Daphnia hybrid genomes" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2013.02.06</p>
  <h2>Reference</h2>

  <p>R Vergilino, TA Elliott, <b>P Desjardins-Proulx</b>, TJ Crease and F
Dufresne. Evolution of a transposon in <i>Daphnia</i> hybrid genomes.
<i>Mobile DNA</i> 4:7, 2013.
<a href="http://dx.doi.org/10.1186/1759-8753-4-7">DOI: 10.1186/1759-8753-4-7.</a></p>


]]></summary>
</entry>
<entry>
    <title>The repeatability of niche and neutral communities</title>
    <link href="http://phdp.github.io//posts/2012-09-24-repeatability.html" />
    <id>http://phdp.github.io//posts/2012-09-24-repeatability.html</id>
    <published>2012-09-24T00:00:00Z</published>
    <updated>2012-09-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>The repeatability of niche and neutral communities</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="The repeatability of niche and neutral communities" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2012.09.24</p>
  <h2>Reference</h2>

  <p>D Ai, <b>P Desjardins-Proulx</b>, C Chu, and G Wang. The influence of
immigration and dispersal limitation on the repeatability of niche and neutral
communities. <i>PLOS ONE</i> 7(9): e46164.  <a
href="http://dx.doi.org/10.1371/journal.pone.0046164">DOI:
10.1371/journal.pone.0046164</a>. <a href="files/ai_2012.pdf">[PDF]</a></p>


]]></summary>
</entry>
<entry>
    <title>Wagner: a simple model to study speciation patterns</title>
    <link href="http://phdp.github.io//posts/2012-09-12-wagner.html" />
    <id>http://phdp.github.io//posts/2012-09-12-wagner.html</id>
    <published>2012-09-12T00:00:00Z</published>
    <updated>2012-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Wagner: a simple model to study speciation patterns</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="Wagner: a simple model to study speciation patterns" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2012.09.12</p>
  <p>This paper describes a very simple model to generate phylogeographies 
  under allopatric/parapatric speciation. The C++11 code is on github: <a href=
  "https://github.com/PhDP/wagner">github.com/PhDP/wagner</a>.</p>

  <p>I have a love/hate relationship with this model. I love it as an 
  algorithm: it's an elegant way to get a speciation-like behavior in space. 
  I hate it because I increasingly doubt this kind of very simplistic 
  'bottom-up' model can bring much ecological insights.</p>
  
  <p>I named this model <i>Wagner</i> in honor of Moritz Wagner, one of the 
  first scientist to argue for the importance of geographic isolation
  in speciation.</p>

<h2>Reference</h2>

  <p><b>P Desjardins-Proulx</b>, JL Rosindell, T Poisot, and D Gravel. A
simple model to study phylogeographies and speciation patterns in space. <a
href="http://arxiv.org/abs/1203.1790">arXiv: 1203.1790</a>, 2012. <a
href="../files/desjardins-proulx_wagner.bib">[BIB]</a></p>


]]></summary>
</entry>
<entry>
    <title>The case for arXiv and a broader conception of peer-reviews</title>
    <link href="http://phdp.github.io//posts/2012-08-22-case-arxiv.html" />
    <id>http://phdp.github.io//posts/2012-08-22-case-arxiv.html</id>
    <published>2012-08-22T00:00:00Z</published>
    <updated>2012-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>The case for arXiv and a broader conception of peer-reviews</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="The case for arXiv and a broader conception of peer-reviews" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2012.08.22</p>
  <h2>Reference</h2>

  <p><b>P Desjardins-Proulx</b>. <a
href="http://innge.net/?q=node/330">The case for arXiv and a broader conception
of peer-reviews</a>. Invited blog for the <i>International Network of
Next-Generation Ecologists</i>, 2012.</p>


]]></summary>
</entry>
<entry>
    <title>A complex speciation-richness relationship in a simple neutral model</title>
    <link href="http://phdp.github.io//posts/2012-06-27-complex.html" />
    <id>http://phdp.github.io//posts/2012-06-27-complex.html</id>
    <published>2012-06-27T00:00:00Z</published>
    <updated>2012-06-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>A complex speciation-richness relationship in a simple neutral model</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-text="A complex speciation-richness relationship in a simple neutral model" data-via="phdpqc">Tweet</a>
<p id="dt"><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>2012.06.27</p>
  <p><b>P Desjardins-Proulx</b> and D Gravel. A complex speciation-richness
relationship in a simple neutral model. <i>Ecology and Evolution</i>
2(8):1781-1790. <a href="http://dx.doi.org/10.1002/ece3.292">DOI:
10.1002/ece3.292</a>.  <a
href="http://onlinelibrary.wiley.com/doi/10.1002/ece3.292/pdf">[PDF]</a> <a
href="http://onlinelibrary.wiley.com/doi/10.1002/ece3.292/full">[HTML]</a> <a
href="files/desjardins-proulx_2012b.bib">[BIB]</a> <a
href="http://arxiv.org/abs/1203.3884">[arXiv]</a> <a
href="https://github.com/PhDP/origin">[C source code]</a></p>


]]></summary>
</entry>

</feed>
