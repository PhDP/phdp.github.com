<!DOCTYPE html>
<html>

<head>
  <meta http-equiv='content-type' content='text/html; charset=utf-8'/>
  <title>Philippe Desjardins-Proulx</title>
  <link rel='stylesheet' media='screen' href='/css/style.css' type='text/css'/>
  <link href='//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css' rel='stylesheet' type='text/css'/>
  <script type='text/x-mathjax-config'>
    MathJax.Hub.Config({tex2jax: {inlineMath: [['\\(','\\)']]}});
  </script>
  <script type='text/javascript' async
    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML'>
  </script>
</head>

<body>

<div id='header'>
  <nav>
    <ul>
      <li>( <a href='/index.html'>Philippe Desjardins-Proulx</a></li>
      <li><a href='/blog/'>blog</a></li>
      <li><a href='/papers/'>publications</a></li>
      <li><a href='https://github.com/PhDP'><i class='fa fa-github'></i></a></li>
      <li><a href='https://ca.linkedin.com/in/philippedp'><i class='fa fa-linkedin-square'></i></a></li>
      <li><a href='mailto:philippe.desjardins.proulx@umontreal.ca'><i class='fa fa-envelope'></i></a></li>
      <li><a href='https://twitter.com/phdpqc'><i class='fa fa-twitter'></i></a></li>
      <li><a style='color:#ff6f00;a:hover{color:#8e240e;text-decoration:none;}' href='/atom.xml'><i class='fa fa-rss'></i></a> )</li>
    </ul>
  </nav>
</div>

<div id='content'>
  
<h1 class="title">
  Automated reasoning in F#, Scala, Haskell, C++, and Julia
</h1>

<p id="dt">2015-04-05</p>

<p><p>We need to simplify the following expression:</p>
<p>[e = (1 + 0 \times x) \times 3 + 12.]</p>
<p>Luckily for us, we won't have to remember any elementary school arithmetic,
because Harris' excellent <a
  href='http://www.cambridge.org/ca/academic/subjects/computer-science/programming-languages-and-applied-logic/handbook-practical-logic-and-automated-reasoning'>
  <i>Handbook of Practical Logic and Automated Reasoning</i></a> begins with a
simple algorithm to do exactly that. It's not complicated, but it's a pretty
good barometer of how painful a programming language will be for the kind of
hybrid (probabilistic logic, or statistical relational) approaches I work with.
Here, I compare the implementations of Harris' simple algorithm in F#, Scala,
Haskell, C++, and Julia.</p>
<p>No programming languages were hurt while writing this post. It's not a
competition, and I avoided talking about languages I dislike. Sum types are
discussed at length because they are awesome and useful for this problem
(and many, many others).</p>
<h2>The ML family</h2>
<p>Harris' book uses OCaml, a popular language for solvers. F#, Haskell, and
Scala all share roots with OCaml, with F# being the closest thing to an OCaml
dialect. I'll start with F#:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#93a1a1;">/// A sum type for the expression.
/// An expression is either a var (which is a string), a constant
/// (which is an integer), an addition (made of two expressions)
/// or a multiplication (also made of two expressions).
</span><span style="color:#859900;">type </span><span style="color:#b58900;">Expr </span><span style="color:#859900;">=
    |</span><span style="color:#657b83;"> Var </span><span style="color:#859900;">of </span><span style="color:#b58900;">string
    </span><span style="color:#859900;">|</span><span style="color:#657b83;"> Const </span><span style="color:#859900;">of </span><span style="color:#b58900;">int
    </span><span style="color:#859900;">|</span><span style="color:#657b83;"> Add </span><span style="color:#859900;">of </span><span style="color:#b58900;">Expr </span><span style="color:#859900;">* </span><span style="color:#b58900;">Expr
    </span><span style="color:#859900;">|</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">of </span><span style="color:#b58900;">Expr </span><span style="color:#859900;">* </span><span style="color:#b58900;">Expr

</span><span style="color:#93a1a1;">/// Simplify a single component of the expression. This function
/// takes an expression and use pattern matching to select the
/// right approach based on type and value. For example, if we
/// add a constant 0 to some x (which can be expression), then
/// we return x.
</span><span style="color:#859900;">let </span><span style="color:#268bd2;">simplify1 e </span><span style="color:#859900;">=
    match</span><span style="color:#657b83;"> e </span><span style="color:#859900;">with
    |</span><span style="color:#657b83;"> Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">,</span><span style="color:#657b83;"> x</span><span style="color:#859900;">)
    |</span><span style="color:#657b83;"> Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Const </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">)
    |</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Const </span><span style="color:#6c71c4;">1</span><span style="color:#859900;">)
    |</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const </span><span style="color:#6c71c4;">1</span><span style="color:#859900;">,</span><span style="color:#657b83;"> x</span><span style="color:#859900;">)        -&gt;</span><span style="color:#657b83;"> x
    </span><span style="color:#859900;">|</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Const </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">)
    |</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">,</span><span style="color:#657b83;"> x</span><span style="color:#859900;">)        -&gt;</span><span style="color:#657b83;"> Const </span><span style="color:#6c71c4;">0
    </span><span style="color:#859900;">|</span><span style="color:#657b83;"> Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const a</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Const b</span><span style="color:#859900;">)  -&gt;</span><span style="color:#657b83;"> Const </span><span style="color:#859900;">(</span><span style="color:#657b83;">a </span><span style="color:#859900;">+</span><span style="color:#657b83;"> b</span><span style="color:#859900;">)
    |</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const a</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Const b</span><span style="color:#859900;">)  -&gt;</span><span style="color:#657b83;"> Const </span><span style="color:#859900;">(</span><span style="color:#657b83;">a </span><span style="color:#859900;">*</span><span style="color:#657b83;"> b</span><span style="color:#859900;">)
    | _                       -&gt;</span><span style="color:#657b83;"> e

</span><span style="color:#93a1a1;">/// Recursive function to simplify an entire expression.
</span><span style="color:#859900;">let rec </span><span style="color:#268bd2;">simplify e </span><span style="color:#859900;">=
    match</span><span style="color:#657b83;"> e </span><span style="color:#859900;">with
    |</span><span style="color:#657b83;"> Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> y</span><span style="color:#859900;">) -&gt;</span><span style="color:#657b83;"> Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">simplify x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> simplify y</span><span style="color:#859900;">)
    |</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> y</span><span style="color:#859900;">) -&gt;</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">simplify x</span><span style="color:#859900;">,</span><span style="color:#657b83;"> simplify y</span><span style="color:#859900;">)
    | _          -&gt;</span><span style="color:#657b83;"> e
    </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> simplify1

</span><span style="color:#93a1a1;">/// Return the value string if the expression can be reduced to a constant.
</span><span style="color:#859900;">let </span><span style="color:#268bd2;">exprStr e </span><span style="color:#859900;">=
    match</span><span style="color:#657b83;"> e </span><span style="color:#859900;">with
    |</span><span style="color:#657b83;"> Const x </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> string x
    </span><span style="color:#859900;">| _       -&gt; </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">The expression could not be simplified to a constant.</span><span style="color:#839496;">&quot;

</span><span style="color:#93a1a1;">/// The |&gt; operator sends the result on its left to its right, for example
/// &quot;5.0 |&gt; log |&gt; sqrt&quot; computes log(5.0) and then the square root of the
/// result. This is nice because it allows a more natural left-to-right
/// flow for functional programming.
</span><span style="color:#859900;">[&lt;EntryPoint&gt;]
let </span><span style="color:#268bd2;">main argv </span><span style="color:#859900;">=</span><span style="color:#657b83;">
    Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">Add </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const </span><span style="color:#6c71c4;">1</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Mul </span><span style="color:#859900;">(</span><span style="color:#657b83;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">,</span><span style="color:#657b83;"> Var </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">x</span><span style="color:#839496;">&quot;</span><span style="color:#859900;">)),</span><span style="color:#657b83;"> Const </span><span style="color:#6c71c4;">3</span><span style="color:#859900;">),</span><span style="color:#657b83;"> Const </span><span style="color:#6c71c4;">12</span><span style="color:#859900;">)
    |&gt;</span><span style="color:#657b83;"> simplify
    </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> exprStr
    </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> printf </span><span style="color:#839496;">&quot;</span><span style="color:#859900;">%s</span><span style="color:#839496;">&quot;
    </span><span style="color:#6c71c4;">0 </span><span style="color:#93a1a1;">/// F#&#39;s main returns 0 for success à la C
</span></code></pre><p>It's almost the same as the OCaml version in Harris' book. The key trick is
to define an expression (Expr) as a variable (string) <b>or</b> a constant
(integer) <b>or</b> an addition <b>or</b> a multiplication (both made of two
expressions). The <b>or</b> is important, object-oriented programming languages
focuses on hierarchies of objects, while sum types define a type as a series of
alternatives. Sum types are important for another reason: they provide
an easy way to express things like "this function <i>might</i> return
an integer", for example in Haskell if we want a data structure that maps
keys to values:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#cb4b16;">import </span><span style="color:#859900;">Data.Map </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">Map</span><span style="color:#657b83;">)
</span><span style="color:#cb4b16;">import qualified </span><span style="color:#859900;">Data.Map </span><span style="color:#cb4b16;">as </span><span style="color:#859900;">Map</span><span style="color:#657b83;">

capitals </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">Map</span><span style="color:#859900;">.</span><span style="color:#657b83;">fromList [(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Finland</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Helsinki</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">), (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">France</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Paris</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">),
  (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Japan</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Tokyo</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">), (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">South Korea</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Seoul</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">), (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Arrakis</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Arrakeen</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">)]

lookupCapitals country </span><span style="color:#859900;">= case </span><span style="color:#cb4b16;">Map</span><span style="color:#859900;">.</span><span style="color:#657b83;">lookup country capitals </span><span style="color:#859900;">of
  </span><span style="color:#cb4b16;">Just</span><span style="color:#657b83;"> capital </span><span style="color:#859900;">-&gt; </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">The capital of </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> country </span><span style="color:#859900;">++ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;"> is </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> capital </span><span style="color:#859900;">++ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">.</span><span style="color:#839496;">&quot;
  </span><span style="color:#cb4b16;">Nothing      </span><span style="color:#859900;">-&gt; </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Is </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> country </span><span style="color:#859900;">++ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;"> even a country?</span><span style="color:#839496;">&quot;
</span></code></pre><p>The point is that a key-value store will only return a value if the key is
present. In this example, the map takes a country (string) and returns its
capital (string). However, when we try to take a value from the map with the
lookup function, Haskell returns a <b>Maybe</b> type with either <b>Just
String</b>, if the string provided is found in the map, or <b>Nothing</b> if
the key is absent. We then use pattern matching to deal with these
possibilities in the lookupCapitals function. One of the most common mistake in
programming is to return a null and not deal with it properly. The solution
with sum types is to return a wrapped value and handling possibilities
explicitly with pattern matching. It solves with types what many languages
would solve with exceptions and try-catch apparatuses.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">ghci</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> lookupCapitals </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Arrakis</span><span style="color:#839496;">&quot;
&quot;</span><span style="color:#2aa198;">The capital of Arrakis is Arrakeen.</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">
ghci</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> lookupCapitals </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Canada</span><span style="color:#839496;">&quot;
&quot;</span><span style="color:#2aa198;">Is Canada even a country?</span><span style="color:#839496;">&quot;
</span></code></pre><p>Speaking of Haskell, the code for the algorithm is:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">data </span><span style="color:#cb4b16;">Expr </span><span style="color:#859900;">=
    </span><span style="color:#cb4b16;">Var String
  </span><span style="color:#859900;">| </span><span style="color:#cb4b16;">Const Int
  </span><span style="color:#859900;">| </span><span style="color:#cb4b16;">Add Expr Expr
  </span><span style="color:#859900;">| </span><span style="color:#cb4b16;">Mult Expr Expr

</span><span style="color:#b58900;">simplify1 </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">Expr </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">Expr
</span><span style="color:#657b83;">simplify1 e </span><span style="color:#859900;">= case</span><span style="color:#657b83;"> e </span><span style="color:#859900;">of
  </span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) x           </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> x
  </span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> x (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)           </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> x
  </span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const</span><span style="color:#657b83;"> a) (</span><span style="color:#cb4b16;">Const</span><span style="color:#657b83;"> b)   </span><span style="color:#859900;">-&gt; </span><span style="color:#cb4b16;">Const </span><span style="color:#859900;">$</span><span style="color:#657b83;"> a </span><span style="color:#859900;">+</span><span style="color:#657b83;"> b
  </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> x (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)          </span><span style="color:#859900;">-&gt; </span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0
  </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) x          </span><span style="color:#859900;">-&gt; </span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0
  </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> x (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)          </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> x
  </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) x          </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> x
  </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const</span><span style="color:#657b83;"> a) (</span><span style="color:#cb4b16;">Const</span><span style="color:#657b83;"> b)  </span><span style="color:#859900;">-&gt; </span><span style="color:#cb4b16;">Const </span><span style="color:#859900;">$</span><span style="color:#657b83;"> a * b
  _                         </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> e

</span><span style="color:#b58900;">simplify </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">Expr </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">Expr
</span><span style="color:#657b83;">simplify e </span><span style="color:#859900;">= case</span><span style="color:#657b83;"> e </span><span style="color:#859900;">of
  </span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> x y   </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> simplify1 </span><span style="color:#859900;">$ </span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> (simplify x) (simplify y)
  </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> x y  </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> simplify1 </span><span style="color:#859900;">$ </span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> (simplify x) (simplify y)
  _         </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> simplify1 e

e </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Add</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) (</span><span style="color:#cb4b16;">Mult</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) (</span><span style="color:#cb4b16;">Var </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">x</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">))) (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">)) (</span><span style="color:#cb4b16;">Const </span><span style="color:#6c71c4;">12</span><span style="color:#657b83;">)
s </span><span style="color:#859900;">=</span><span style="color:#657b83;"> simplify e

main </span><span style="color:#859900;">=</span><span style="color:#657b83;"> putStrLn </span><span style="color:#859900;">$ case</span><span style="color:#657b83;"> s </span><span style="color:#859900;">of
  </span><span style="color:#cb4b16;">Const</span><span style="color:#657b83;"> x </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> show x
  _ </span><span style="color:#859900;">-&gt; </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Could not simplify the expression to a constant.</span><span style="color:#839496;">&quot;
</span></code></pre><p>It's quite similar to F#. I decided to add types explicitly to
<i>simplify1</i> and <i>simplify</i>, but Haskell is smart enough to deduce the
type without this. Arguably the only thing worth explaining is the $ operator.
The operator forces Haskell to evaluate the expression to the right of the
operator in priority, and if it reminds you of parentheses, you are absolutely
right. <i>x</i> and <i>y</i> have the same value here:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">x </span><span style="color:#859900;">=</span><span style="color:#657b83;"> log (sqrt (exp </span><span style="color:#6c71c4;">5.0</span><span style="color:#657b83;">))
y </span><span style="color:#859900;">=</span><span style="color:#657b83;"> log </span><span style="color:#859900;">$</span><span style="color:#657b83;"> sqrt </span><span style="color:#859900;">$</span><span style="color:#657b83;"> exp </span><span style="color:#6c71c4;">5.0
</span></code></pre><p>The operator is there to reduce visual clutter. In my opinion, F# is easier
to read because the |> operator enforces left-to-right reading, which is more
natural than reading code inside-out:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let </span><span style="color:#268bd2;">z </span><span style="color:#859900;">=</span><span style="color:#657b83;"> exp </span><span style="color:#6c71c4;">5.0 </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> sqrt </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> log
</span></code></pre><p>Although it's trivial to simulate this operator in Haskell:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#b58900;">(|&gt;) </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">t0 </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> (</span><span style="color:#268bd2;">t0 </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">t1</span><span style="color:#657b83;">) </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">t1
</span><span style="color:#b58900;">(|&gt;)</span><span style="color:#657b83;"> x f </span><span style="color:#859900;">=</span><span style="color:#657b83;"> f x

</span><span style="color:#93a1a1;">-- Now valid Haskell:
</span><span style="color:#657b83;">z </span><span style="color:#859900;">=</span><span style="color:#657b83;"> exp </span><span style="color:#6c71c4;">5.0 </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> sqrt </span><span style="color:#859900;">|&gt;</span><span style="color:#657b83;"> log
</span></code></pre><p>And now for something a bit different: Scala. It's also a static
functional programming language with sum types, but its greater
integration with the object-oriented paradigm is evident:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#268bd2;">object</span><span style="color:#b58900;"> Simplify </span><span style="color:#657b83;">{
  </span><span style="color:#586e75;">sealed abstract </span><span style="color:#268bd2;">class</span><span style="color:#b58900;"> Expr </span><span style="color:#657b83;">{ </span><span style="color:#586e75;">override </span><span style="color:#268bd2;">def </span><span style="color:#b58900;">toString </span><span style="color:#657b83;">= show(</span><span style="color:#d33682;">this</span><span style="color:#657b83;">) }
  </span><span style="color:#268bd2;">case class</span><span style="color:#b58900;"> Variable</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">name</span><span style="color:#657b83;">: </span><span style="color:#859900;">String</span><span style="color:#657b83;">) </span><span style="color:#859900;">extends </span><span style="color:#268bd2;">Expr
  case class</span><span style="color:#b58900;"> Const</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">value</span><span style="color:#657b83;">: </span><span style="color:#268bd2;">Int</span><span style="color:#657b83;">) </span><span style="color:#859900;">extends </span><span style="color:#268bd2;">Expr
  case class</span><span style="color:#b58900;"> Add</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">left</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">right</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">) </span><span style="color:#859900;">extends </span><span style="color:#268bd2;">Expr
  case class</span><span style="color:#b58900;"> Mult</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">left</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">right</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">) </span><span style="color:#859900;">extends </span><span style="color:#268bd2;">Expr

  def </span><span style="color:#b58900;">evalOne</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">e</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">): </span><span style="color:#859900;">Expr </span><span style="color:#657b83;">= e </span><span style="color:#859900;">match </span><span style="color:#657b83;">{
    </span><span style="color:#859900;">case Add</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">), </span><span style="color:#268bd2;">r</span><span style="color:#657b83;">)         </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> r
    </span><span style="color:#859900;">case Add</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">l</span><span style="color:#657b83;">, </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">))         </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> l
    </span><span style="color:#859900;">case Add</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">a</span><span style="color:#657b83;">), </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">b</span><span style="color:#657b83;">))  </span><span style="color:#268bd2;">=&gt; </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(a + b)
    </span><span style="color:#859900;">case Mult</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">), </span><span style="color:#268bd2;">r</span><span style="color:#657b83;">)        </span><span style="color:#268bd2;">=&gt; </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
    </span><span style="color:#859900;">case Mult</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">l</span><span style="color:#657b83;">, </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">))        </span><span style="color:#268bd2;">=&gt; </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
    </span><span style="color:#859900;">case Mult</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">), </span><span style="color:#268bd2;">r</span><span style="color:#657b83;">)        </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> r
    </span><span style="color:#859900;">case Mult</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">l</span><span style="color:#657b83;">, </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">))        </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> l
    </span><span style="color:#859900;">case Mult</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">a</span><span style="color:#657b83;">), </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">b</span><span style="color:#657b83;">)) </span><span style="color:#268bd2;">=&gt; </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(a * b)
    </span><span style="color:#859900;">case </span><span style="color:#d33682;">_                        </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> e
  }

  </span><span style="color:#268bd2;">def </span><span style="color:#b58900;">eval</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">e</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">): </span><span style="color:#859900;">Expr </span><span style="color:#657b83;">= e </span><span style="color:#859900;">match </span><span style="color:#657b83;">{
    </span><span style="color:#859900;">case Add</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">l</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">r</span><span style="color:#657b83;">)  </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> evalOne(</span><span style="color:#859900;">Add</span><span style="color:#657b83;">(eval(l), eval(r)))
    </span><span style="color:#859900;">case Mult</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">l</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">r</span><span style="color:#657b83;">) </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> evalOne(</span><span style="color:#859900;">Mult</span><span style="color:#657b83;">(eval(l), eval(r)))
    </span><span style="color:#859900;">case </span><span style="color:#d33682;">_          </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> e
  }

  </span><span style="color:#268bd2;">def </span><span style="color:#b58900;">show</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">e</span><span style="color:#657b83;">: </span><span style="color:#859900;">Expr</span><span style="color:#657b83;">) = e </span><span style="color:#859900;">match </span><span style="color:#657b83;">{
    </span><span style="color:#859900;">case Const</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">x</span><span style="color:#657b83;">) </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;"> print(x)
    </span><span style="color:#859900;">case </span><span style="color:#d33682;">_        </span><span style="color:#268bd2;">=&gt;</span><span style="color:#657b83;">
      print(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">The expression could not be simplified to a constant.</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">)
  }

  </span><span style="color:#268bd2;">def </span><span style="color:#b58900;">main</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">args</span><span style="color:#657b83;">: </span><span style="color:#859900;">Array</span><span style="color:#657b83;">[</span><span style="color:#859900;">String</span><span style="color:#657b83;">]) {
    </span><span style="color:#268bd2;">var e </span><span style="color:#657b83;">= </span><span style="color:#859900;">Add</span><span style="color:#657b83;">(</span><span style="color:#859900;">Mult</span><span style="color:#657b83;">(</span><span style="color:#859900;">Add</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">), </span><span style="color:#859900;">Mult</span><span style="color:#657b83;">(</span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">), </span><span style="color:#859900;">Variable</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">x</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">))),
              </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">)), </span><span style="color:#859900;">Const</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">12</span><span style="color:#657b83;">))
    </span><span style="color:#268bd2;">var s </span><span style="color:#657b83;">= eval(e)
    print(s)
  }
}
</span></code></pre><p>Everything is an object in Scala. Thus, we have to define the functions to
simplify as methods inside a singleton object. I named the functions
<i>evalOne</i> and <i>eval</i> since it has a bit odd to have a function named
<i>simplify</i> inside a Simplify object.</p>
<h2>C++</h2>
<p>Few understand every corner of C++'s monstrous standard. It's huge.  Surely,
with so many features, there must something to solve this
simple problem cleanly.  Well... no. It's a well-known lacuna with C++,
see <a href="https://parasol.tamu.edu/~yuriys/pm/"><i>Open and
Efficient Type Switch for C++</i></a> for a library built to implement
pattern matching (the effort is directed by the creator
of the C++ language). That said, here I'll use the boost library (A)
because solutions based only on the standard library are contrived and
(B) because boost is almost standard, and I don't want to rely on third-party
libraries.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#cb4b16;">#include </span><span style="color:#839496;">&lt;</span><span style="color:#2aa198;">iostream</span><span style="color:#839496;">&gt;
</span><span style="color:#cb4b16;">#include </span><span style="color:#839496;">&lt;</span><span style="color:#2aa198;">string</span><span style="color:#839496;">&gt;
</span><span style="color:#cb4b16;">#include </span><span style="color:#839496;">&lt;</span><span style="color:#2aa198;">boost/variant.hpp</span><span style="color:#839496;">&gt;

</span><span style="color:#93a1a1;">// Forward declarations:
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">add</span><span style="color:#657b83;">;
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">mult</span><span style="color:#657b83;">;

</span><span style="color:#93a1a1;">// The variant for the expression:
</span><span style="color:#859900;">using </span><span style="color:#b58900;">expr </span><span style="color:#657b83;">= boost::variant&lt;
  </span><span style="color:#268bd2;">int</span><span style="color:#657b83;">,
  std::string,
  boost::recursive_wrapper&lt;add&gt;,
  boost::recursive_wrapper&lt;mult&gt;&gt;;

</span><span style="color:#93a1a1;">// A base class for all binary operations:
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">binary_op </span><span style="color:#657b83;">{
  expr </span><span style="color:#268bd2;">m_left</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">m_right</span><span style="color:#657b83;">;

</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
  </span><span style="color:#93a1a1;">// Builds a binary operation from left and right expressions.
  </span><span style="color:#b58900;">binary_op</span><span style="color:#657b83;">(expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">left</span><span style="color:#657b83;">, expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">right</span><span style="color:#657b83;">)
    : </span><span style="color:#268bd2;">m_left</span><span style="color:#657b83;">(left), </span><span style="color:#268bd2;">m_right</span><span style="color:#657b83;">(right) {
  }

  </span><span style="color:#93a1a1;">// Returns the expression to the left side of the expression.
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">left</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr </span><span style="color:#859900;">const&amp; </span><span style="color:#657b83;">{
    </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_left</span><span style="color:#657b83;">;
  }

  </span><span style="color:#93a1a1;">// Returns the expression to the right side of the expression.
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">right</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr </span><span style="color:#859900;">const&amp; </span><span style="color:#657b83;">{
    </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_right</span><span style="color:#657b83;">;
  }
};

</span><span style="color:#93a1a1;">// Defines the &#39;add&#39; operator.
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">add </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">binary_op </span><span style="color:#657b83;">{
  </span><span style="color:#b58900;">add</span><span style="color:#657b83;">(expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">left</span><span style="color:#657b83;">, expr </span><span style="color:#859900;">const &amp;</span><span style="color:#268bd2;">right</span><span style="color:#657b83;">)
    : </span><span style="color:#268bd2;">binary_op</span><span style="color:#657b83;">(left, right) {
  }
};

</span><span style="color:#93a1a1;">// Defines the &#39;mult&#39; operator.
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">mult </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">binary_op </span><span style="color:#657b83;">{
  </span><span style="color:#b58900;">mult</span><span style="color:#657b83;">(expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">left</span><span style="color:#657b83;">, expr </span><span style="color:#859900;">const &amp;</span><span style="color:#268bd2;">right</span><span style="color:#657b83;">)
    : </span><span style="color:#268bd2;">binary_op</span><span style="color:#657b83;">(left, right) {
  }
};

</span><span style="color:#93a1a1;">// Overload * and + to simplify creating expressions.

</span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator+</span><span style="color:#657b83;">(expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">lhs</span><span style="color:#657b83;">, expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">rhs</span><span style="color:#657b83;">) -&gt; expr {
  </span><span style="color:#859900;">return </span><span style="color:#b58900;">add</span><span style="color:#657b83;">{lhs, rhs};
}

</span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator*</span><span style="color:#657b83;">(expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">lhs</span><span style="color:#657b83;">, expr </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">rhs</span><span style="color:#657b83;">) -&gt; expr {
  </span><span style="color:#859900;">return </span><span style="color:#b58900;">mult</span><span style="color:#657b83;">{lhs, rhs};
}

</span><span style="color:#93a1a1;">// A visitor for addition.
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">add_visit </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">boost::static_visitor</span><span style="color:#657b83;">&lt;expr&gt; {
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int lhs</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">int rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs + rhs};
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> R&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int lhs</span><span style="color:#657b83;">, R </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return</span><span style="color:#657b83;"> lhs == </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">? </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs} </span><span style="color:#859900;">: </span><span style="color:#b58900;">add</span><span style="color:#657b83;">{</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs}, </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs}};
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> L&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(L </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">lhs</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">int rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr{
    </span><span style="color:#859900;">return</span><span style="color:#657b83;"> rhs == </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">? </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs} </span><span style="color:#859900;">: </span><span style="color:#b58900;">add</span><span style="color:#657b83;">{</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs}, </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs}};
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> L, </span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> R&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(L </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">lhs</span><span style="color:#657b83;">, R </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#b58900;">add</span><span style="color:#657b83;">{</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs}, </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs}};
  }
};

</span><span style="color:#93a1a1;">// A visitor for multiplication.
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">mul_visit </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">boost::static_visitor</span><span style="color:#657b83;">&lt;expr&gt; {
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int lhs</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">int rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs </span><span style="color:#859900;">*</span><span style="color:#657b83;"> rhs};
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> R&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int lhs</span><span style="color:#657b83;">, R </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return</span><span style="color:#657b83;"> lhs == </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">?
      </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">} </span><span style="color:#859900;">: </span><span style="color:#657b83;">(lhs == </span><span style="color:#6c71c4;">1</span><span style="color:#859900;">? </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs} </span><span style="color:#859900;">: </span><span style="color:#b58900;">mult</span><span style="color:#657b83;">{</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs}, </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs}});
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> L&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(L </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">lhs</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">int rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return</span><span style="color:#657b83;"> rhs == </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">?
      </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">} </span><span style="color:#859900;">: </span><span style="color:#657b83;">(rhs == </span><span style="color:#6c71c4;">1</span><span style="color:#859900;">? </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs} </span><span style="color:#859900;">: </span><span style="color:#b58900;">mult</span><span style="color:#657b83;">{</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs}, </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs}});
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> L, </span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> R&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(L </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">lhs</span><span style="color:#657b83;">, R </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">rhs</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#b58900;">mult</span><span style="color:#657b83;">{</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{lhs}, </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{rhs}};
  }
};

</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">simplify1 </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">boost::static_visitor</span><span style="color:#657b83;">&lt;expr&gt; {
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(add </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">a</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#657b83;">boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">add_visit</span><span style="color:#657b83;">{}, a.</span><span style="color:#b58900;">left</span><span style="color:#657b83;">(), a.</span><span style="color:#b58900;">right</span><span style="color:#657b83;">());
  }

  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(mult </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">m</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#657b83;">boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">mul_visit</span><span style="color:#657b83;">{}, m.</span><span style="color:#b58900;">left</span><span style="color:#657b83;">(), m.</span><span style="color:#b58900;">right</span><span style="color:#657b83;">());
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> T&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(T </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">t</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{t};
  }
};

</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">simplify </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">boost::static_visitor</span><span style="color:#657b83;">&lt;expr&gt; {
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(add </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">a</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> left = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify</span><span style="color:#657b83;">{}, a.</span><span style="color:#b58900;">left</span><span style="color:#657b83;">());
    </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> right = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify</span><span style="color:#657b83;">{}, a.</span><span style="color:#b58900;">right</span><span style="color:#657b83;">());
    </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> add_lr = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">add_visit</span><span style="color:#657b83;">{}, left, right);
    </span><span style="color:#859900;">return </span><span style="color:#657b83;">boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify1</span><span style="color:#657b83;">{}, add_lr);
  }

  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(mult </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">m</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> left = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify</span><span style="color:#657b83;">{}, m.</span><span style="color:#b58900;">left</span><span style="color:#657b83;">());
    </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> right = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify</span><span style="color:#657b83;">{}, m.</span><span style="color:#b58900;">right</span><span style="color:#657b83;">());
    </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> mul_lr = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">mul_visit</span><span style="color:#657b83;">{}, left, right);
    </span><span style="color:#859900;">return </span><span style="color:#657b83;">boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify1</span><span style="color:#657b83;">{}, mul_lr);
  }

  </span><span style="color:#268bd2;">template</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">typename</span><span style="color:#657b83;"> T&gt;
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(T </span><span style="color:#859900;">const&amp; </span><span style="color:#268bd2;">t</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; expr {
    </span><span style="color:#859900;">return </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{t};
  }
};

</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">print_expr </span><span style="color:#657b83;">: </span><span style="color:#859900;">public </span><span style="color:#268bd2;">boost::static_visitor</span><span style="color:#657b83;">&lt;std::string&gt; {
  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int n</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; std::string {
    </span><span style="color:#859900;">return </span><span style="color:#657b83;">std::</span><span style="color:#b58900;">to_string</span><span style="color:#657b83;">(n);
  };

  </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">operator()</span><span style="color:#657b83;">(expr </span><span style="color:#859900;">const&amp;</span><span style="color:#657b83;">) </span><span style="color:#859900;">const </span><span style="color:#657b83;">-&gt; std::string {
    </span><span style="color:#859900;">return </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">The expression could not be simplified to a constant.</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">;
  };
};

</span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#268bd2;">int </span><span style="color:#657b83;">{
  </span><span style="color:#859900;">const </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> e = (</span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">} + </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">} </span><span style="color:#859900;">* </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">x</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">}) </span><span style="color:#859900;">* </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">} + </span><span style="color:#b58900;">expr</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">12</span><span style="color:#657b83;">};
  </span><span style="color:#859900;">const </span><span style="color:#268bd2;">auto</span><span style="color:#657b83;"> s = boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">simplify</span><span style="color:#657b83;">{}, e);
  std::cout &lt;&lt; boost::</span><span style="color:#b58900;">apply_visitor</span><span style="color:#657b83;">(</span><span style="color:#b58900;">print_expr</span><span style="color:#657b83;">{}, s) &lt;&lt; std::endl;
  </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">;
}
</span></code></pre><p>This is boost::variant in action. My biggest qualm with this type of clever
header-heavy code is that you get to see a big chunk of the developers'
lifework unroll before your eyes every time a small mistake is made. Otherwise
it's an OK substitute for proper sum types/pattern matching. If you want to know
how this code works, you need to read a bit on the visitor pattern.</p>
<h2>Julia</h2>
<p>Julia is an attempt to build a fast and flexible replacement for
R/Python/Matlab.  An issue with most dynamic languages is that there is no
elegant way to switch on type. To be fair, you cannot really do it with most
static languages either, see previous section... However, Julia supports
multiple-dispatch based on type annotation. To be clear, it's quite different
from the F#/Scala/Haskell approach.  In these languages, it is possible to define
sum types and do pattern matching on their constructors. With Julia, we define a
function with type annotation and let the interpreter dispatch based on runtime
type information. Multiple dispatch is supported in Julia for performance: it
allows the interpreter to compile optimized functions and use the best one,
adding predictability while keeping the language dynamic (for some reason...).
Here's the algorithm in Julia:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">abstract Expr

type Const </span><span style="color:#859900;">&lt;:</span><span style="color:#657b83;"> Expr; val</span><span style="color:#859900;">::</span><span style="color:#657b83;">Int </span><span style="color:#859900;">end</span><span style="color:#657b83;">
type Var </span><span style="color:#859900;">&lt;:</span><span style="color:#657b83;"> Expr; name</span><span style="color:#859900;">::</span><span style="color:#657b83;">String </span><span style="color:#859900;">end</span><span style="color:#657b83;">
type Add </span><span style="color:#859900;">&lt;:</span><span style="color:#657b83;"> Expr; left</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr; right</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr </span><span style="color:#859900;">end</span><span style="color:#657b83;">
type Mult </span><span style="color:#859900;">&lt;:</span><span style="color:#657b83;"> Expr; left</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr; right</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr </span><span style="color:#859900;">end</span><span style="color:#657b83;">

add(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const) = Const(x.val </span><span style="color:#859900;">+</span><span style="color:#657b83;"> y.val)
add(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) = x.val </span><span style="color:#859900;">== </span><span style="color:#6c71c4;">0</span><span style="background-color:#ec9489;color:#657b83;">?</span><span style="color:#657b83;"> y </span><span style="color:#859900;">:</span><span style="color:#657b83;"> Add(x, y)
add(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const) = add(y, x)
add(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) = Add(x, y)

mult(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const) = Const(x.val </span><span style="color:#859900;">*</span><span style="color:#657b83;"> y.val)
mult(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) = x.val </span><span style="color:#859900;">== </span><span style="color:#6c71c4;">1</span><span style="background-color:#ec9489;color:#657b83;">?</span><span style="color:#657b83;"> y </span><span style="color:#859900;">: </span><span style="color:#657b83;">(x.val </span><span style="color:#859900;">== </span><span style="color:#6c71c4;">0</span><span style="background-color:#ec9489;color:#657b83;">?</span><span style="color:#657b83;"> Const(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#859900;">: </span><span style="color:#657b83;">Mult(x, y))
mult(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const) = mult(y, x)
mult(x</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr, y</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) = Mult(x, y)

simplify</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">(a</span><span style="color:#859900;">::</span><span style="color:#657b83;">Add) = add(a.left, a.right)
simplify</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">(m</span><span style="color:#859900;">::</span><span style="color:#657b83;">Mult) = mult(m.left, m.right)
simplify</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">(e</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) = e

simplify(a</span><span style="color:#859900;">::</span><span style="color:#657b83;">Add) = simplify</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">(Add(simplify(a.left), simplify(a.right)))
simplify(m</span><span style="color:#859900;">::</span><span style="color:#657b83;">Mult) = simplify</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">(Mult(simplify(m.left), simplify(m.right)))
simplify(e</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) = e

printExpr(c</span><span style="color:#859900;">::</span><span style="color:#657b83;">Const) = print(c.val)
printExpr(e</span><span style="color:#859900;">::</span><span style="color:#657b83;">Expr) =
  print(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">The expression could not be simplified to a constant.</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">)

e = Add(Mult(Add(Const(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">), Mult(Const(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">), Var(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">x</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">))), Const(</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">)), Const(</span><span style="color:#6c71c4;">12</span><span style="color:#657b83;">))
s = simplify(e)
printExpr(s)
</span></code></pre><p>Unlike pattern matching, we can only dispatch on type, so we need an if
expression (the ? operator in Julia, just like C), or I could've used the match
macro, but it's overkill here. It's not too inelegant, and at first I thought
it was a good enough way to simulate sum types and pattern matching. It matters
to the Julia ecosystem because these features are very useful to build solvers,
logic and theorem proving systems, etc etc. Pretty nice for a technical
computing platform. Unfortunately, while Julia does well with this simple example,
I think an oddity with the language would soon bite us: return type declarations
are not allowed, and yes, it <i>is</i> a big deal.</p>
<p>First, it's a question of correctness: you can return a float thinking
you're returning an integer. Also, since annotations are not
allowed for the return value, it's also impossible to add annotation for a
higher-order function (a function taking functions as input). As a concrete
example, first-order logic has <i>predicates</i> mapping objects to a boolean,
and <i>functions</i> mapping objects to objects. We'd like to do:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">solve(pre</span><span style="color:#859900;">::</span><span style="color:#657b83;">(Object </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> Bool), ...)

solve(fun</span><span style="color:#859900;">::</span><span style="color:#657b83;">(Object </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> Object), ...)
</span></code></pre><p>But instead, we'd have to test the type of the return value inside the
function. That said, Julia is young and <a
href='https://github.com/JuliaLang/julia/issues/1090'>it might get return type
declarations at some point.</a></p>
<h2>Conclusion</h2>
<p>Sum types and pattern matching are awesome.</p>
</p>


  <div id='hidden'>
    <p><a href='/reading/'>(∀m: Medium . m &lt; <span id='jp'>本</span>)</a></p>
  </div>
</div>

</body>
</html>
