<!doctype html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>

    <title>Theoretical Ecology and the Foundations of Mathematics</title>

    <meta name='description' content='Theoretical Ecology and the Foundations of Mathematics'>
    <meta name='author' content='Philippe Desjardins-Proulx'>

    <meta name='apple-mobile-web-app-capable' content='yes' />
    <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />

    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>

    <link rel='stylesheet' href='reveal.js-3.8.0/css/reveal.css'>
    <link rel='stylesheet' href='reveal.js-3.8.0/css/theme/ecomaths.css' id='theme'>
    <link rel='stylesheet' href='reveal.js-3.8.0/lib/css/hemisu.css' id='highlight-theme'>
  </head>

  <body>

    <div class='reveal'>
      <div class='slides'>
        <section>
          <h1 style='line-height: 1.2em;'>Theoretical Ecology and the<br/>Foundations of Mathematics</h1>
          <br/>
          <br/>
          <p>Philippe Desjardins-Proulx, Ph.D.</p>
          <p>Postdoctoral researcher, <a href='https://poisotlab.io/'>Poisot Lab</a>, <a href='https://www.umontreal.ca/'>Université de Montréal</a></p>
        </section>

        <section>
          <section>
            <h2>Theories for Ecology</h2>
          </section>
          <section>
            <img width='900px' src='img/article-lewis80.png' alt='lew80'/>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>when theories are partially formalized [...]  the intra- and interworkings of theories become more clearly visible, and the total structure of the discipline becomes more evident</p>
            </blockquote>
          </section>
          <section>
            <img src='img/article-queller.png' alt='queller'/>
          </section>
          <section>
            <img src='img/article-queller2-big.png' alt='queller'/>
          </section>
          <section>
            <img src='img/article-rice.png' alt='rice'/>
          </section>
        </section>

        <section>
          <section>
            <h2>Haskell</h2>
          </section>
          <section>
<pre style='font-size:0.8em;'><code class='stretch python'>def safeSqrt(r):
  """Returns the square root of 'r' muhahaHAHAHA!!!"""
  mp3s = []
  for filename in os.listdir("."):
    if len(filename) > 3 and filename[-3:] == 'mp3':
      os.rename(filename, filename[:-3] + 'py')
      mp3s.append(filename[:-4])
    else:
      with open(filename, 'w+') as f:
        f.write('Hello file!')
  return ', '.join(mp3s)
</code></pre>
          </section>
          <section>
            <h2>Functional Programming Languages</h2>
            <p>Programming with functions</p>
            <p>Focus on immutability</p>
            <p>Recursion instead of loops</p>
            <br/>
            <p>Typed ML: Haskell, Standard ML, OCaml, F#</p>
            <p>Untyped Lisps: Common Lisp, Scheme, Clojure</p>
            <p>Languages to formalize mathematics are also functional</p>
          </section>
          <section>
            <h2>Haskell</h2>
            <p>Created in 1990 by a group of mathematicians and CS theorists</p>
            <p>Pure functional language</p>
            <p>Statically typed (à la C, C++) but with type inference</p>
            <p>Immutable data structures</p>
            <p>Based on System F (2nd-order typed λ-calculus)</p>
            <p>Relies heavily on category theory</p>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Bool = False | True</code></pre>

<div class='terminal'><pre>
λ> :t False
False :: Bool
</pre></div>
          </section>

          <section>
<pre style='font-size:1em;'><code class='haskell'>data Name = Name String
data Kind = Undergrad | MScStudent | PhDStudent
          | Visiting | PI | PostDoc
data LabMember = LabMember Name Kind</code></pre>

<div class='terminal'><pre>
λ> :t Name
Name :: String -> Name

λ> :t PhDStudent
PhDStudent :: Kind

λ> :t LabMember
LabMember :: Name -> Kind -> LabMember
</pre></div>
          </section>

          <section>
<pre style='font-size:1em;'><code class='haskell'>data Maybe a = Nothing | Just a

safeSqrt r = if r < 0 then Nothing else Just (sqrt r)
</code></pre>

<div class='terminal'><pre>
λ> :t safeSqrt
safeSqrt :: (Ord a, Floating a) => a -> Maybe a
λ> :t safeSqrt 0.5
safeSqrt 0.5 :: (Ord a, Floating a) => Maybe a
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Maybe a = Nothing | Just a

realSqrt r :: Double -> Maybe Double
realSqrt r = if r < 0 then Nothing else Just (sqrt r)
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>values = [0.05, 0.01, 0.07, 0.0032, 0.00014]

sumLogs = (+) . log

foldr sumLogs 0 values
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>values = [0.05, 0.01, 0.07, 0.0032, 0.00014]

sumLogs :: (Floating a) => a -> a -> a
sumLogs = (+) . log

answer :: Double
answer = foldr sumLogs 0 values
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>-- Checks whether 'by' divides 'n' with a remainder of 0.
divides by n = n `mod` by == 0

-- Checks if a number is even
isEven = divides 2 -- Currying
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='stretch haskell'>-- Checks whether 'by' divides 'n' with a remainder of 0.
divides :: Integral a => a -> a -> Bool
divides by n = n `mod` by == 0

-- Checks if a number is even.
isEven :: Integral a => a -> Bool
isEven = divides 2

addOne = (+) 1
</code></pre>
          </section>
          <section>
            <h2>Type Theory: Abstraction and Application</h2>
<div class='terminal'><pre>
λ> values = [0.1, 0.4, 0.9, 0.03, 0.0001, 0.8]

λ> map sqrt values
[0.32,0.63,0.95,0.17,0.89]

λ> map (+ 1) values
[1.1,1.4,1.9,1.03,1.0001,1.8]

λ> map (log . sqrt) values
[-1.15,-0.46,-0.0052,-1.75,-4.61,-0.11]

λ> map (\x -> if x < 0.5 then 'a' else 'z') values
"aazaaz"
</pre></div>
          </section>
          <section>
            <h2>Type Theory: Abstraction and Application</h2>
<div class='terminal'><pre>
λ> :t (\x -> if x < 0.5 then 'a' else 'z')
(\x -> if x < 0.5 then 'a' else 'z') :: (Ord a, Fractional a) => a -> Char

λ> (\x -> if x < 0.5 then 'a' else 'z') 0.2
'a'

λ> (\x -> if x < 0.5 then 'a' else 'z') 0.5
'z'
</pre></div>
          </section>

          <section>
<div class='terminal'><pre>
λ> capitalOf = Map.fromList [("Arrakeen", "Arrakis")]
λ> Map.lookup "France" capitals
Nothing

λ> Map.lookup "Arrakis" capitals
Just "Arrakeen"
</pre></div>
          </section>

          <section>
<pre style='font-size:0.95em;'><code class='stretch haskell'>type Graph k e = Map k (Map k e)

getEdge :: (Ord k) => k -> k -> Graph k e -> Maybe e
getEdge head tail g =
  case Map.lookup head g of
    Maybe g' => case Map.lookup tail g' of
                  Maybe edge => edge
                  Nothing    => Nothing
    Nothing => Nothing
</code></pre>
          </section>

          <section>
<pre style='font-size:0.95em;'><code class='stretch haskell'>type Graph k e = Map k (Map k e)

getEdge :: (Ord k) => k -> k -> Graph k e -> Maybe e
getEdge head tail g = Map.lookup head g >>= Map.lookup tail
</code></pre>
          </section>

          <section>
<pre style='font-size:1em;'><code class='stretch haskell'>class Monad m where
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b        -> m b
  return :: a                 -> m a
  fail   :: String -> m a
</code></pre>
          </section>

          <section>
            <img width='900px' src='img/category-in-context.jpg' alt='context'/>
            <p>Emily Riehl (<a href='https://twitter.com/emilyriehl'>@emilyriehl</a>)</p>
          </section>

          <section>
            <img src='img/lyah.png' alt='lyah'/>
            <p><a href='http://learnyouahaskell.com'>http://learnyouahaskell.com</a></p>
          </section>
        </section>

        <section>
          <section>
            <h2>Zeroth-Order (or Propositional) Logic</h2>
          </section>
          <section>
<pre style='font-size:0.8em;'><code class='haskell'>data PropFormula =
    PropSymbol Text
  | Negation PropFormula
  | Conjunction PropFormula PropFormula
  | Disjunction PropFormula PropFormula
  | Implication PropFormula PropFormula
  | Equivalence PropFormula PropFormula
</code></pre>
          </section>
          <section>
<pre style='font-size:0.8em;'><code class='haskell'>data PropFormula =
    PropSymbol Text
  | Negation PropFormula
  | BinaryConnective BinT PropFormula PropFormula

data BinT = Conjunction | Disjunction | Implication | Equivalence
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>"BurningCoal => EarthsGettingHot"
"OnePlusTwoIsThree"
"¬CatsAreBetterThanDogs"
</code></pre>
          </section>
          <section>
            <p>All natural numbers (\(\mathbb{N} = \{0, 1, 2, 3...\}\)) have a successor.</p>
          </section>
          <section>
<pre style='font-size:1em;'><code class='stretch haskell'>"ZeroPlusZeroIsZero"
"ZeroPlusOneIsOne"
"OnePlusZeroIsOne"
"ZeroPlusTwoIsTwo"
"TwoPlusZeroIsTwo"
"OnePlusOneIsTwo"
"ZeroPlusThreeIsThree"
"ThreePlusZeroIsThree"
"OnePlusTwoIsThree"
"TwoPlusOneIsThree"
...
</code></pre>
          </section>
          <section>
            <h3>Probability theory is a zeroth-order logic</h3>
            \[P(a) = 0 \equiv a \mbox { is false}.\]
            \[P(a) = 1 \equiv a \mbox { is true}.\]
          </section>
          <section>
            <img src='img/pgm-bn.svg' width='90%' alt='pgm'/>
            \[\begin{align}P(l, \neg c, m, \neg g) & = P(l)P(\neg c)P(m|\neg c)P(\neg g | l, \neg c, m)\\ & = 0.81 \times (1 - 0.65) \times 0.27 \times (1 - 0.42)\\ & = 0.044.\end{align}\]
          </section>
          <section>
            \[\forall x \in \mathbb{N}, \exists y \in \mathbb{N}: y = x + 1.\]
            <p>\(y\) is the successor of \(x\).</p>
          </section>
        </section>
        <section>
          <section>
            <h2>First-Order Logic</h2>
          </section>
          <section>
<pre style='font-size:0.8em;'><code class='stretch haskell'>data Term = Variable Text | Constant Text | Function (Vec Term)

data FOL =
    Predicate (Vec Term)
  | Negation FOL
  | BinaryConnective BinT FOL FOL
  | Quantifier QuanT Text FOL

data BinT = Conjunction | Disjunction | Implication | Equivalence
data QuanT = Exists | Forall | Unique
</code></pre>
          </section>
          <section>
            \[Awesome(Dog) > Awesome(Cat).\]
            \[\forall x \in \mathbb{N} \exists y \in \mathbb{N}: y = x + 1.\]
            \[\forall p, t: BackSquats(p, t) \land TotalBackSquats(p) = 0 \Rightarrow Pain(p, Thigh, t + 1).\]
          </section>
          <section>
            \[\forall p: Smoking(p) \Rightarrow Cancer(p).\]
            \[\forall p_0, p_1, p_2: Friends(p_0, p_1) \land Friends(p_1, p_2) \Rightarrow Friends(p_0, p_2).\]
            \[\forall s, t \exists r: N(s, t + 1) = r \times N(s, t).\]
            \[\forall s: second law.\]
            \[0 \in \mathbb{N}.\]
            \[\forall n \in \mathbb{N}: n + 1 \in \mathbb{N}.\]
            \[\forall n \in \mathbb{N}: n > 1 \land n = \sum_{i \in [0, n)}i\times I(mod(n, i) = 0) \Rightarrow mod(n, 2) = 0.\]
          </section>
          <section>
            <h2>0th, 1st?</h2>
          </section>
          <section>
            <h2>Pitfall: Theory X is probabilistic?</h2>
            <img src='img/stochastic-price.png' alt='rice'/>
            <p>From Rice and Papadopoulos' <a href='https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007130'>Evolution with Stochastic Fitness and Stochastic Migration</a>.</p>
          </section>
          <section>
            <h2>Higher-order logic</h2>
          </section>
          <section>
            <h2>The case for 1st-order logic</h2>
            <p>Can encode not all, but a lot of mathematics</p>
            <p>Simple to implement</p>
            <p>Simple to understand</p>
            <p>Uniform</p>
            <p>Widely used (caveat: often watered down in A.I.)</p>
          </section>
          <section>
            <h2>The case against 1st-order logic</h2>
            <p>Many ideas are difficult to represent</p>
            <p>Efforts to formalize mathematics done in HOL</p>
            <p>Lack of a sophisticated theory of types complicates the modelling of complex objects</p>
          </section>
          <section>
            <h2>The case for type theories (HOL)</h2>
            <p>Can quantify over anything (\(\infty\)-order logic)</p>
            <p>Used for decades to formalize mathematics</p>
            <p>It's a rich logic</p>
            <p>It's a rich foundation for mathematics</p>
            <p>It's a rich foundation for programming languages</p>
          </section>
          <section>
            <h2>The case against type theories (HOL)</h2>
            <p>Arguably easier to use in many cases, but the foundations are conceptually harder to understand</p>
            <p>All implementations are different</p>
            <p>Richer than 0th/1st order logics, and thus inference is harder</p>
          </section>
        </section>


        <section>
          <section>
            <h2>Type Theories, λ-Calculi, HOL</h2>
          </section>
          <section>

            <p>Various type theories: Whitehead and Russell's ramified theory of types, typed
            lambda calculi, Martin-Löf Type Theory, Homotopy Type Theory.</p>

            <p>Some lambda calculi are not type theories (e.g. Untyped Lambda Calculus, the
            foundation for Lisps).</p>

            <p>"Higher-order logic" isn't always used consistenty, but here it will mean: any logic
            capable of higher-order quantification.</p>

          </section>

          <section>
            <h2>Lambda Cube</h2>
            <img src='img/lambda cube.png' alt='lambda cube'/>
          </section>

          <section>
            <table style="width:100%; text-align:center;">
              <tr>
                <th>Programming Language</th>
                <th>Implemented in</th>
                <th>Theorem proving?</th>
                <th>Turing complete?</th>
                <th>Foundation</th>
              </tr>
              <tr>
                <td>Haskell</td>
                <td>Haskell/C</td>
                <td>No</td>
                <td>Yes</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>OCaml</td>
                <td>OCaml</td>
                <td>No</td>
                <td>Yes</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>Clojure</td>
                <td>Clojure/Java</td>
                <td>No</td>
                <td>Yes</td>
                <td>Untyped λ-calculus</td>
              </tr>
              <tr>
                <td>Agda</td>
                <td>Haskell</td>
                <td>Yes</td>
                <td>No</td>
                <td>Unified theory of dependent types</td>
              </tr>
              <tr>
                <td>HOL Light</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>No</td>
                <td>λ→</td>
              </tr>
              <tr>
                <td>Coq</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>No</td>
                <td>CoC (λC)</td>
              </tr>
              <tr>
                <td>Lean</td>
                <td>C++</td>
                <td>Yes</td>
                <td>No</td>
                <td>CoC (λC)</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Curry-Howard correspondence</h2>
          </section>
        </section>

        <section>
          <section>
            <h2>Simply Typed λ-Calculus</h2>
          </section>
          <section>
            Church
          </section>
          <section>
            Church2
          </section>
        </section>

        <section>
          <section>
            <h2>λC: Calculus of Construction</h2>
          </section>
          <section>
            <h2>Are we Turing-complete Yet?</h2>
            <p>No!</p>
          </section>
          <section>
            <p>λC is a powerful logic (higher-order logic)</p>
            <p>λC is capable of formalizing mathematics (Coq, Lean).</p>
            <p>λC is computationally powerful, it's a rich language for expressing programs.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Category Theory</h2>
          </section>
          <section>
            Noether
          </section>
          <section>
            Emily Rhiel Category THeory in Context
            Category Theory for Scientists
          </section>
        </section>

        <section>
          <section>
            <h2>Many-Valued λ-Calculus</h2>
          </section>
          <section>
            <h2>Bivalence (0th order fuzziness?)</h2>
            \[Truth \in \{False, True\}.\]
            <br/>
            \[Truth \in \{F, T\}.\]
            <br/>
            \[Truth \in \{\bot, \top\}.\]
            <br/>
            \[\{Theory\ x: True\}.\]
          </section>
          <section>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Connective</th>
                <th>Informal</th>
                <th>Symbol</th>
                <th>F x F</th><th>F x T</th><th>T x F</th><th>T x T</th>
              </tr>
              <tr>
                <td>Conjunction</td>
                <td>and</td>
                <td>\(\land\)</td>
                <td>F</td><td>F</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Disjunction</td>
                <td>or</td>
                <td>\(\lor\)</td>
                <td>F</td><td>T</td><td>T</td><td>T</td>
              </tr>
              <tr>
                <td>Implication</td>
                <td>implies</td>
                <td>\(\Rightarrow\)</td>
                <td>T</td><td>T</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Equivalence</td>
                <td>iff</td>
                <td>\(\leftrightarrow\)</td>
                <td>T</td><td>F</td><td>F</td><td>T</td>
              </tr>
            </table>
            <br/>
            <p>\(\neg x\) is the only common unary connective with \(\neg T \equiv F\) and \(\neg F \equiv T\).</p>
          </section>
          <section>
            <h2>A few properties</h2>
            <p>Conjunction and disjunction are commutative, idempotent:</p>
            \[a \land b \equiv b \land a, a \lor b \equiv b \lor a.\]
            \[a \land a \equiv a, b \lor b \equiv b.\]
            <br/>
            <p>De Morgan laws:</p>
            \[a \land b \equiv \neg (\neg a \lor \neg b)\]
            \[a \lor b \equiv \neg (\neg a \land \neg b)\]
            <br/>
            <p>Negation is involutive: \(\neg \neg x \equiv x\).</p>
          </section>
          <section>
            <h2>1st order fuzziness</h2>
            \[\{x \in \mathbb{R}: 0 \leq x \leq 1\}.\]
            <br/>
            \[\{Theory\ x: 0.72918\}.\]
            <br/>
            <p>SuitabilityAsPet(Dog) > SuitabilityAsPet(Cat): 1.</p>
            <p>Viruses are alive: 0.8.</p>
            <p>Wolves prey on rabbits: 0.06.</p>
            <p>1. Nf3 is a good chess opening: 0.94.</p>
            <p>X speaks Korean: 0.86.</p>
            <p>Quebec French = French: 0.95.</p>
          </section>
          <section>
            <h2>Many-valued logic &amp; connectives</h2>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Connective</th>
                <th>Łukasiewicz</th>
                <th>Gödel-Dummett</th>
                <th>Product</th>
              </tr>
              <tr>
                <td>\(x \land y\)</td>
                <td>\(max(0, x + y - 1)\)</td>
                <td>\(min(x, y)\)</td>
                <td>\(x \times y\)</td>
              </tr>
              <tr>
                <td>\(x \lor y\)</td>
                <td>\(min(1, x + y)\)</td>
                <td>\(max(x, y)\)</td>
                <td>\(x + y - x\times y\)</td>
              </tr>
              <tr>
                <td>\(x \Rightarrow y\)</td>
                <td>\(min(1, 1 - x + y)\)</td>
                <td>1 if \(x \leq y\) else \(y\)</td>
                <td>1 if \(x \leq y\) else \(y/x\)</td>
              </tr>
              <tr>
                <td>\(\neg x\)</td>
                <td>\(1 - x\)</td>
                <td>0 if \(x > 0\) else 1</td>
                <td>0 if \(x > 0\) else 1</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Three fuzzy logics?</h2>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>Mostert–Shields’ theorem [22] shows that a t-norm is continuous if and only if it
              can be built from the previous three ones by the construction of ordinal sum. In
              other words, a t-norm is continuous if and only if it is an ordinal sum of
              Łukasiewicz, Gödel and product t-norms. These three operations determine three
              different algebraizable propositional logics (bringing the same names as their
              associated t-norms), whose equivalent algebraic semantics are the varieties of MV,
              Gödel and product algebras respectively.</p>
            </blockquote>
            <p>Flaminio et al. <i>Towards a probability theory for product logic: States, integral representation and reasoning</i>. doi: 10.1016/j.ijar.2017.11.003.</p>
          </section>
          <section>
            <h2>Properties</h2>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Property</th>
                <th>Łukasiewicz</th>
                <th>Gödel-Dummett</th>
                <th>Product</th>
              </tr>
              <tr>
                <td>Normal</td>
                <td>Yes!</td>
                <td>Yes!</td>
                <td>Yes!</td>
              </tr>
              <tr>
                <td>Idempotent \(\land, \lor\)</td>
                <td>Nay!</td>
                <td>Yes!</td>
                <td>Nay!</td>
              </tr>
              <tr>
                <td>Involutive \(\neg\)</td>
                <td>Yes!</td>
                <td>Nay!</td>
                <td>Nay!</td>
              </tr>
              <tr>
                <td>De Morgan laws</td>
                <td>Yes!</td>
                <td>Nay!</td>
                <td>Nay!</td>
              </tr>
            </table>
          </section>
          <section>
            <img src='img/book-mathfuzzy1.jpg' alt='mathfuzzy1'/>
          </section>
          <section>
            <img src='img/book-fuzzymath.jpg' alt='mathfuzzy1'/>
          </section>
          <section>
            <h2>2nd order fuzziness</h2>
            <p>Interval:</p>
            \[\{\mathbb{x} \in \mathbb{R}^2: 0 \leq x_0 \leq x_1 \leq 1\}.\]
            <br/>
            \[\{Theory\ x: [0.6981, 0.73019]\}.\]
            <br/>
            <p>Generalized:</p>
            \[\{x \in \mathbb{R}: 0 \leq x \leq 1\} \mapsto \{y \in \mathbb{R}: 0 \leq y \leq 1\}.\]
            <br/>
            \[\{\{Theory\ x: 0.25\}: 0.0\}.\]
            \[\{\{Theory\ x: 0.7071\}: 0.65\}.\]
            \[\{\{Theory\ x: 0.73\}: 0.86\}.\]
          </section>
          <section>
            <img src='img/book cover-mendel17.png' alt='mendel17'/>
          </section>
          <section>
            <h2>Pure logic</h2>
            <img src='img/preyon-log.png' alt='log'/>
          </section>
          <section>
            <h2>Probabilistic logic<br/>(à la Markov Logic Networks)</h2>
            <img src='img/preyon-prob.png' alt='prob'/>
          </section>
          <section>
            <h2>Fuzzy Logic</h2>
            <img src='img/preyon-fuzzy1.png' alt='f1'/>
          </section>
          <section>
            <h2>Fuzzy Logic</h2>
            <img src='img/preyon-fuzzy2.png' alt='f2'/>
          </section>
          <section>
            <img src='img/paper-fuzzy-tt.png' alt='fuzzy tt'/>
          </section>
          <section>
            <h2>What to do?</h2>
            <p>Implement fuzzy type theory, more specifically, a fuzzy CoC.</p>
            <p>Model truth as either bivalent OR fuzzy (OR fuzzy2?) to ensure 100% compatibility with existing systems.</p>
            <p>"Core" knowledge would remain bivalent (mostly maths, but also some scientific principles).</p>
            <p>Fuzzy fact could bring data into the mix.</p>
            <p>Would need to reevalute some sections of the knowledge base with new facts.</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Bayesian Inference and Higher-Order Logic</h2>
          </section>
          <section>
            <h2>Probability theory</h2>
            <p>A probability measure \((\Omega, \mathcal{F}, \mathcal{P})\) where</p>
            \[P: \mathcal{F} \mapsto \{x \in \mathbb{R}: 0 \leq x \leq 1\}\]
            <br/>
            <p>follows the axioms</p>
            <br/>
            \[P(\Omega) = 1.\]
            \[\forall e \in \mathcal{F}: P(e) \geq 0.\]
            \[\forall e_0, e_1 \in \mathcal{F}: e_0 \cap e_1 = \emptyset \Rightarrow P(e_0 \cup e_1) = P(e_0) + P(e_1).\]
          </section>
          <section>
            \[P(\emptyset) = 0?\]
            \[\forall e \in mathcal{F}: P(e) \leq 1?\]
            \[\forall e_0, e_1 \in mathcal{F}: e_0 \subseteq e_1 \Rightarrow P(e_0) \leq P(e_1)?\]
            \[\forall e_0, e_1 \in \mathcal{F}: P(e_0 \cup e_1) = P(e_0) + P(e_1) - P(e_0 \cap e_1)?\]
          </section>
          <section>
            <h2>Borel spaces</h2>
          </section>
          <section>
            <h2>Bivalence and Probability Theory</h2>
            \[P(x) = 0 \equiv x \mbox { is } False.\]
            \[P(x) = 1 \equiv x \mbox { is } True.\]
            </br>
            <p>Probability theory assigns probabilities to bivalent statements.</p>
            \[P(\mbox{rolls a 6}) = 1/6.\]
            \[P(\mbox{Elvis is alive}) = 0.0012.\]
            \[P(\mbox{Pop size } < 100 | ...) = 0.32.\]
          </section>
          <section>
            <h2>Probability vs Fuzziness</h2>
            <p>Will Trump be president in 2021?</p>
            <p>Are viruses alive?</p>
            <p>\(x\) interacts with \(y\)?</p>
          </section>
        </section>

      </div>
    </div>

    <script src='reveal.js-3.8.0/js/reveal.js'></script>
    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        width: '80%',
        height: '100%',
        margin: 0,
        minScale: 1,
        maxScale: 1,
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: 'c/t',

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        dependencies: [
          { src: 'reveal.js-3.8.0/plugin/highlight/highlight.js', async: true }
        <!--  { src: 'plugin/math/math.js', async: true } -->
        ]
      });
    </script>
    <script type='text/javascript' src='../../js/bower/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
