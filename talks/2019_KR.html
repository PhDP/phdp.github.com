<!doctype html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>

    <title>Theoretical Ecology and the Foundations of Mathematics</title>

    <meta name='description' content='Theoretical Ecology and the Foundations of Mathematics'/>
    <meta name='author' content='Philippe Desjardins-Proulx'/>

    <meta name='apple-mobile-web-app-capable' content='yes' />
    <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />

    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/>

    <link rel='stylesheet' href='reveal.js-3.8.0/css/reveal.css'/>
    <link rel='stylesheet' href='reveal.js-3.8.0/css/theme/ecomaths.css' id='theme'/>
    <link rel='stylesheet' href='reveal.js-3.8.0/lib/css/hemisu.css' id='highlight-theme'/>
  </head>

  <body>

    <div class='reveal'>
      <div class='slides'>
        <section>
          <h1 style='line-height: 1.2em;'>Theoretical Ecology and the<br/>Foundations of Mathematics</h1>
          <br/>
          <br/>
          <p>Philippe Desjardins-Proulx, Ph.D.</p>
          <p>Postdoctoral researcher, <a href='https://poisotlab.io/'>Poisot Lab</a>, <a href='https://www.umontreal.ca/'>Université de Montréal</a></p>
        </section>

        <section>
          <section>
            <h2>Theories for Ecology</h2>
          </section>
          <section>
            <img width='900px' src='img/article-lewis80.png' alt='lew80'/>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>when theories are partially formalized [...] the intra- and interworkings of theories become more clearly visible, and the total structure of the discipline becomes more evident</p>
            </blockquote>
          </section>
          <section>
            <img src='img/article-queller.png' alt='queller'/>
          </section>
          <section>
            <img src='img/article-queller2-big.png' alt='queller'/>
          </section>
          <section>
            <img src='img/article-rice.png' alt='rice'/>
          </section>
          <section>
            <img src='img/article-xiao2015.png' alt='MaxEnt'/>
          </section>
          <section>
            <img src='img/article-mcgill.png' alt='McGill'/>
          </section>
          <section>
            <img src='img/article-logic-theorist.png' alt='logic theorist'/>
          </section>
          <section>
            <h2>Probability theory</h2>
            <p>A probability measure \((\Omega, \mathcal{F}, \mathcal{P})\) where</p>
            \[P: \mathcal{F} \mapsto \{x \in \mathbb{R}: 0 \leq x \leq 1\}.\]
            <br/>
            <p>Follows the axioms:</p>
            <br/>
            \[P(\Omega) = 1.\]
            \[\forall e \in \mathcal{F}: P(e) \geq 0.\]
            \[\forall e_0, e_1 \in \mathcal{F}: e_0 \cap e_1 = \emptyset \Rightarrow P(e_0 \cup e_1) = P(e_0) + P(e_1).\]
          </section>
          <section>
            \[P(\emptyset) = 0?\]
            \[\forall e \in mathcal{F}: P(e) \leq 1?\]
            \[\forall e_0, e_1 \in mathcal{F}: e_0 \subseteq e_1 \Rightarrow P(e_0) \leq P(e_1)?\]
            \[\forall e_0, e_1 \in \mathcal{F}: P(e_0 \cup e_1) = P(e_0) + P(e_1) - P(e_0 \cap e_1)?\]
          </section>
          <section>
            <h2>Goals</h2>
            <p><b>0. Implement a language powerful enough to represent mathematical ideas and complex relationships between objects (λC &amp; full FOL)</b></p>
            <p><b>1. Study {many-valued, probabilistic} extensions and how they can be used to encode ecological knowledge.</b></p>
            <p><b>2. Develop and encode ecological theories in our extended languages.</b></p>
            <p><b>3. Symbolic regression for machine learning within our extended languages.</b></p>
          </section>
          <section>
            <h2>Projects</h2>
            <p><b>Sandbox: </b><a href='https://github.com/PhDP/Faun'>Faun</a> (Haskell). To play and test with various ideas. Has already quite a bit of code (mostly first-order logic).</p>
            <p><b>Main project</b>: A more focused Rust project.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Zeroth-Order (or Propositional) Logic</h2>
          </section>
          <section>
            <p>Is the most primitive logic.</p>
            <p>Bivalent, so truth: \(\{False, True\} \equiv \{F, T\} \equiv \{\bot, \top\}\).</p>
          </section>
          <section>
            <p>Given a set of propositional symbols \(\mathcal{S}\):</p>
            <ol start='0'>
              <li>If \(s \in \mathcal{S}\), then \(s\) is a WFF.</li>
              <li>If \(f\) is a WFF, then \(\neg f\) is a WFF.</li>
              <li>If \(f_0, f_1\) are WFFs, then \(f_0 \star f_1\) is a WFF.</li>
            </ol>
            <p>With \(\star = \{\land, \lor, \Rightarrow, \leftrightarrow, \veebar\}.\)</p>
          </section>
          <section>
            <table style='width: 60%; text-align:center;'>
              <tr>
                <th>Connective</th>
                <th>Informal</th>
                <th>Symbol</th>
                <th>F x F</th><th>F x T</th><th>T x F</th><th>T x T</th>
              </tr>
              <tr>
                <td>Conjunction</td>
                <td>and</td>
                <td>\(\land\)</td>
                <td>F</td><td>F</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Disjunction</td>
                <td>or</td>
                <td>\(\lor\)</td>
                <td>F</td><td>T</td><td>T</td><td>T</td>
              </tr>
              <tr>
                <td>Implication</td>
                <td>implies</td>
                <td>\(\Rightarrow\)</td>
                <td>T</td><td>T</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Equivalence</td>
                <td>iff</td>
                <td>\(\equiv, \Leftrightarrow\)</td>
                <td>T</td><td>F</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Exclusive disjunction</td>
                <td>xor</td>
                <td>\(\veebar\)</td>
                <td>F</td><td>T</td><td>T</td><td>F</td>
              </tr>
            </table>
          </section>
          <section>
            \[a \land (b \lor c) \Rightarrow d.\]
            \[Fever \land (Cough \lor AchingMuscles) \Rightarrow Flu.\]
            \[CrustaceaIsMonophyletic \Rightarrow TrumpIsAStableGenius.\]
            \[CrustaceaIsMonophyletic \veebar (CrustaceaIsParaphyletic \lor CrustaceaIsPolyphyletic).\]
            \[OnePlusTwoIsThree.\]
            \[\neg PlutoIsAPlanet\]
          </section>
          <section>
            <h2>Modus Ponens</h2>
            \[\frac{\alpha \Rightarrow \beta, \alpha}{\beta} \mbox{ or } \frac{\alpha \Rightarrow \beta, \alpha}{\therefore \beta}  \mbox{ or } \frac{\Gamma \vdash \alpha \Rightarrow \beta, \Gamma \vdash \alpha}{\Gamma \vdash \beta}.\]
            <br/>
<pre style='font-size:1em;color:#000'>\begin{equation}
  \infer{\beta}{\alpha \Rightarrow \beta & \alpha}.
\end{equation}</pre>
          </section>
          <section>
            <p>\(\alpha \Rightarrow \beta:\) If Kathryn likes Star Trek, then she likes Star Wars.</p>
            <p>\(\alpha:\) Kathryn likes Star Trek.</p>
            <p>\(\therefore \beta:\) Therefore, Kathryn likes Star Wars.</p>
            <br/>
            <br/>
            <p><i>May not reflect reality!</i></p>
          </section>
          <section>
            <h2>Modus Tollens</h2>
            \[\frac{\alpha \Rightarrow \beta, \neg \beta}{\neg \alpha}.\]
          </section>
          <section>
            <p>\(\alpha \Rightarrow \beta:\) If Cosmo is a serial killer, then he has a cat.</p>
            <p>\(\neg \beta:\) Cosmo doesn't have a cat.</p>
            <p>\(\therefore \neg \alpha:\) Therefore, Cosmo is not a serial killer.</p>
            <br/>
            <br/>
            <p><i>Absolutely reflect reality (p-value < 0.001).</i></p>
          </section>
          <section>
            <h2>A Party of Rules!</h2>
            \[\frac{\neg \neg \alpha}{\alpha}.\]
            \[\frac{\alpha \land \beta}{\alpha}.\]
            \[\frac{\alpha \Rightarrow \beta}{\neg \alpha \lor \beta}.\]
            \[...\]
          </section>
          <section>
            <h3>Probability theory is a zeroth-order logic</h3>
            \[P(a | b).\]
            <br/>
            <br/>
            \[P(a) = 0 \equiv a \mbox { is false}.\]
            \[P(a) = 1 \equiv a \mbox { is true}.\]
          </section>
          <section>
            <img src='img/pgm-bn.svg' width='80%' alt='pgm'/>
            \[\begin{align}P(l, \neg c, m, \neg g) & = P(l)P(\neg c)P(m|\neg c)P(\neg g | l, \neg c, m)\\ & = 0.81 \times (1 - 0.65) \times 0.27 \times (1 - 0.42)\\ & = 0.044.\end{align}\]
          </section>
          <section>
            <h2>Pros and Cons of Propositional Logic</h2>
            <p>It's couldn't be simpler.</p>
            <p>Cannot represent complex relationships or mathematical ideas.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>First-Order Logic</h2>
          </section>
          <section>
            <h2>Term</h2>
            <p>Given a set of variables \(\mathcal{V}\), a set of constants \(\mathcal{C}\), and
            a set of functions \(\mathcal{F}\):</p>
            <ol start='0'>
              <li>If \(v \in \mathcal{V}\), then \(v\) is a term.</li>
              <li>If \(c \in \mathcal{C}\), then \(c\) is a term.</li>
              <li>If \(f \in \mathcal{F}\) and \(\mathbf{t}\) is a vector of terms, then \(f(\mathbf{t})\) is a term.</li>
            </ol>
          </section>
          <section>
            \[b + 2^8.\]
            \[Addition(b, Exponentiation(2, 8)).\]
            \[CapitalOf(Finland).\]
            \[NativeLanguage(Marie\ Curie).\]
          </section>
          <section>
            <h2>Formula</h2>
            <p>Given a set of predicates \(\mathcal{P}\):</p>
            <ol start='0'>
              <li>If \(p \in \mathcal{P}\) and \(\mathbf{t}\) is a vector of terms, then \(p\) is a WFF.</li>
              <li>If \(f\) is a WFF, then \(\neg f\) is a WFF.</li>
              <li>If \(f_0, f_1\) are WFFs, then \(f_0 \star f_1\) is a WFF.</li>
              <li>If \(v \in \mathcal{V}\) and \(f\) is a WFF, then \(\diamondsuit v: f\) is a WFF.</li>
            </ol>
            <p>\(\star = \{\land, \lor, \Rightarrow, \leftrightarrow, \veebar\}.\)</p>
            <p>\(\diamondsuit = \{\forall, \exists, \exists!\}\).</p>
          </section>
          <section>
            <p>An <b>interpretation</b> tells us whether a symbol refers to a constant, function, or
            predicate, and what is its domain.</p>

            \[e = m \times C^2.\]
            \[z = s \times h^2.\]
            \[\forall s: Autotroph(s) \lor [\exists p: PreyOn(s, p)].\]
            \[\forall x, y: \dot{x} = \alpha x - \beta xy \land \dot{y} = \delta xy - \gamma y.\]
            \[Monophyletic(Crustacea) \Rightarrow Stable(Trump) \land Genius(Trump).\]
            \[\forall x \in \mathbb{R}: x \geq 0 \Rightarrow \sqrt{x^2} = x.\]
          </section>
          <section>
            <h2>Context</h2>
            \[\forall x, y: Friends(x, y) \land Smoking(x) \Rightarrow Smoking(y).\]
            \[\forall x, y: PreyOn(x, y) \land \neg Parasite(x) \Rightarrow M(x) > M(y).\]
            \[\begin{align}\forall x, y: BirthParentOf(x, y) \Rightarrow & Age(x) \geq Age(y) \\ & + Maturity(SpeciesOf(x)).\end{align}\]
            <br/>
            \[\forall x, y: P(x, y) \equiv P(y, x).\]
          </section>
          <section>
            <h2>Paper-Tiger Logic</h2>
            <p>In A.I.: first-order logic often refer to watered down version of the language (e.g. SQL).</p>
            <p>In particular, functions are often not allowed.</p>
            <p>Without functions, first-order logic is just a logic. With functions, it can represent a large class of mathematical ideas.</p>
          </section>
          <section>
            <img src='img/har09-inference-rules.png' alt='inference rules'/>
          </section>
          <section>
            <img src='img/book-fol.png' alt='fol'/>
            <p>From J Harrison's <i>Handbook Of Practical Logic And Automated Reasoning</i>, Cambridge University Press, 2009.</p>
          </section>
          <section>
            \[\forall n, by: Divisor(n, by) \equiv mod(n, by) = 0.\]
            \[\forall n: Even(n) \equiv Divisor(n, 2).\]
            \[\forall n: Perfect(n) \equiv n > 1 \land n = 1 + \sum_{i \in [2, n)}i\times I(Divisor(n, i)).\]
            \[\forall n: Perfect(n) \Rightarrow Even(n)?\]
          </section>
          <section>
            <h2>Who cares about \(\mathbb{N}\)?</h2>
            <p>With \(x, y \in \mathbb{N}: x - y \in \mathbb{Z}\).</p>
            <p>With \(x \in \mathbb{Z}, y \in \mathbb{N}: (x / y) \in \mathbb{Q}\).</p>
            <p>\(\mathbb{R}\) is a lot more work, but the idea is roughly to define \(x \in \mathbb{R}\) as a sequence of rationals converging to \(x\).</p>
            <p>Probability theory requires \(\mathbb{R}\) (among other things).</p>
          </section>
          <section>
            <h2>Peano axioms (1/3)</h2>
            \[0 \in \mathbb{N}.\]
            \[\forall x \in \mathbb{N}: x = x.\]
            \[\forall x, y \in \mathbb{N}: x = y \Rightarrow y = x.\]
            \[\forall x, y, z \in \mathbb{N}: x = y \land y = z \Rightarrow x = z.\]
          </section>
          <section>
            <h2>Peano axioms (2/3)</h2>
            \[\forall x, y: x \in \mathbb{N} \land x = y \Rightarrow y \in \mathbb{N}.\]
            \[\forall x \in \mathbb{N}: S(x) \in \mathbb{N}.\]
            \[\forall x, y \in \mathbb{N}: x = y \equiv S(x) = S(y).\]
            \[\forall x \in \mathbb{N}: \neg(S(n) = 0).\]
          </section>
          <section>
            <h2>Peano axioms (3/3)</h2>
            \[\forall P: P(0) \land [\forall x \in \mathbb{N}: P(x) \Rightarrow P(S(x))] \Rightarrow [\forall x \in \mathbb{N}: P(x)].\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[Reach(t, h) \Leftrightarrow t = h.\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[Reach(t, h) \Leftrightarrow t = h \lor Edge(t, h).\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[\begin{align}Reach(t, h) & \Leftrightarrow t = h \\ & \lor Edge(t, h) \\ & \lor [\exists x: Edge(t, x) \land Edge(x, h)].\end{align}\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[\begin{align}Reach(t, h) & \Leftrightarrow t = h \\ & \lor Edge(t, h) \\ & \lor [\exists x: Edge(t, x) \land Edge(x, h)] \\ & \lor [\exists x, y: Edge(t, x) \land Edge(x, y) \land Edge(y, h)] \\ & \lor [\exists x, y, z: Edge(t, x) \land Edge(x, y) \land Edge(y, z) \land Edge(z, h)].\end{align}\]
          </section>
          <section>
            <h2>Markov Logic</h2>

            <p>\(Fr(Person, Person):\) Whether the first person is friend with the second person.</p>
            <p>\(Sm(Person):\) Whether the person smokes.</p>
            <p>\(Ca(Person):\) Whether the person has or had cancer.</p>
          </section>
          <section>
            <h2>Markov Logic</h2>

            \[\forall x: Sm(x) \Rightarrow Ca(x); 1.5.\]
            \[\forall x: \neg[\exists y: Fr(x, y)] \Rightarrow Sm(x); 2.3.\]
            \[\forall x, y, z: Fr(x, y) \land Fr(y, z) \Rightarrow Fr(x, z); 0.7.\]
            \[\forall x, y: Fr(x, y) \Rightarrow [Sm(x) \equiv Sm(y)]; 1.1\]

            <p>Weights \(\in \mathbb{R}\).</p>
          </section>
          <section>
            <h2>Markov Logic</h2>
            <p>With a set of persons \(\{A, B\}\):</p>
            <br/>

            \[P(Ca(A) | Fr(B, A), Ca(B)).\]
            \[P(Ca(A) | Fr(B, A), Ca(B), \forall x, y: Fr(x, y) \equiv Fr(y, x); 4.5).\]
          </section>
          <section>
            <h2>Issues with Markov Logic</h2>

            <p>Has an old, unmaintained C++ implementation that runs on a single thread.</p>
            <p>A good logic, but doesn't handle functions well.</p>

            \[\forall x, y: \dot(x) = \alpha x - \beta xy \land \dot(y) = \delta xy - \gamma y; 0.0.\]
          </section>
          <section>
            <h2>Pitfall 1 of 8128: _ is probabilistic</h2>
            <img src='img/stochastic-price.png' alt='rice'/>
            <p>From Rice and Papadopoulos' <a href='https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007130'>Evolution with Stochastic Fitness and Stochastic Migration</a>.</p>
          </section>
          <section>
            <h2>The Case <b>for</b> First-Order Logic</h2>
            <p>Can encode not all, but a lot of mathematics.</p>
            <p>Simple to implement.</p>
            <p>Simple to understand.</p>
            <p>Well-understood.</p>
            <p>Uniform.</p>
            <p>Widely used (caveat: often watered down in A.I.).</p>
          </section>
          <section>
            <h2>The Case <b>for</b> First-Order Logic</h2>
            <p>You can have built-in types for, well, anything: integer, natural numbers, etc.</p>
            <p>You can also often get around the limitations of first-order logic, e.g. \(CanReach(x, y)\).</p>
          </section>
          <section>
            <h2>The Case <b>Against</b> First-Order Logic</h2>
            <p>Many ideas are difficult to represent.</p>
            <p>Essentially based on set theory, which is awkward to handle complex objects.</p>
            <p>Efforts to formalize mathematics done with type theories.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Type Theories</h2>
          </section>
          <section>
            <img src='img/article-lean.png' alt='lean'/>
          </section>
          <section>
            <img src='img/articles-safeml.png' alt='safeml'/>
          </section>
          <section>
            <img src='img/article-farmer2006.png' alt='stt'/>
          </section>
          <section>

            <p>Various type theories: Whitehead and Russell's ramified theory of types, typed
            lambda calculi, Simple Type Theory, Martin-Löf Type Theory, Homotopy Type Theory.</p>

            <p>Some lambda calculi are not based on type theory (e.g. Untyped Lambda Calculus, the
            foundation for Lisps).</p>

            <p>"Higher-order logic" isn't always used consistenty, but here it will mean: any logic
            capable of higher-order quantification.</p>

          </section>
          <section>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Language</th>
                <th>Implemented in</th>
                <th>TP?</th>
                <th>Foundation</th>
              </tr>
              <tr>
                <td>Haskell</td>
                <td>Haskell/C</td>
                <td>No</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>OCaml</td>
                <td>OCaml</td>
                <td>No</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>Clojure</td>
                <td>Clojure/Java</td>
                <td>No</td>
                <td>Untyped λ-calculus</td>
              </tr>
              <tr>
                <td>Isabelle</td>
                <td>ML</td>
                <td>Yes</td>
                <td>Weak type theory</td>
              </tr>
              <tr>
                <td>Agda</td>
                <td>Haskell</td>
                <td>Yes</td>
                <td>Unified Theory of Dependent Types</td>
              </tr>
              <tr>
                <td>HOL Light</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>Simple Type Theory</td>
              </tr>
              <tr>
                <td>Coq</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>CoC (λC)</td>
              </tr>
              <tr>
                <td>Lean</td>
                <td>C++</td>
                <td>Yes</td>
                <td>CoC (λC)</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Python "Function"</h2>
<pre style='font-size:0.8em;'><code class='stretch python'>def safeSqrt(r):
  """Returns the square root of 'r' muhahaHAHAHA!!!"""
  mp3s = []
  for filename in os.listdir("."):
    if len(filename) > 3 and filename[-3:] == 'mp3':
      os.rename(filename, filename[:-3] + 'py')
      mp3s.append(filename[:-4])
    else:
      with open(filename, 'w+') as f:
        f.write('Hello file!')
  return ', '.join(mp3s) if len(mp3) > 10 else 0
</code></pre>
          </section>
          <section>
            <h2>Untyped λ-Calculus</h2>
            <p>Given a set of variables \(\mathcal{V}\), the set of all valid lambda terms \(\Lambda\):</p>
            <ol start='0'>
              <li>Variable: If \(v \in \mathcal{V}\), then \(v \in \Lambda\).</li>
              <li>Abstraction: If \(v \in \mathcal{V}\) and \(M \in \Lambda\), then \((\lambda v . M) \in \Lambda\).</li>
              <li>Application: If \(M\) and \(N \in \Lambda\), then \(M N \in \Lambda\).</li>
            </ol>
          </section>
          <section>
            <h2>Untyped λ-Calculus</h2>
            <p>Given a set of variables \(\mathcal{V}\), the set of all valid lambda terms \(\Lambda\):</p>
            \[\Lambda = \mathcal{V} \mid (\Lambda \Lambda) \mid (\lambda \mathcal{V} . \Lambda). \]
          </section>
          <section>
            <h2>Functions have only one argument</h2>
            \[divides := \lambda\ b . (\lambda n . \dots).\]
            \[isEven := divides\ 2.\]
          </section>
          <section>
            <h2>Simply Typed λ-Calculus</h2>
            <p></p>
            \[\mathbb{T} = \mathbb{A} \mid \mathbb{T} \to \mathbb{T}.\]
            \[\Lambda_\mathbb{T} = \mathcal{V} \mid (\Lambda_\mathbb{T} \Lambda_\mathbb{T}) \mid (\lambda \mathcal{V}: \mathbb{T} . \Lambda_\mathbb{T}).\]
          </section>
          <section>
            <h2>Lambda Cube</h2>
            <img src='img/lambda cube.png' alt='lambda cube'/>
          </section>
          <section>
            <h2>Curry-Howard(–Lambek) correspondence</h2>
            <p>TL;DR: A program is a proof.</p>
            <br/>
            \[\frac{\Gamma \vdash \alpha \Rightarrow \beta, \Gamma \vdash \alpha}{\Gamma \vdash \beta}.\]
            <br/>
            \[\frac{\Gamma \vdash E_0 : \alpha \to \beta, \Gamma \vdash E_1: \alpha}{\Gamma E_0 E_1 : \beta}.\]
          </section>
          <section>
            <p>Complexity of proofs: \(\mathcal{O}\)(¯\_(ツ)_/¯).</p>
          </section>
          <section>
            <h2>Functional Programming Languages</h2>
            <p>Programming with functions</p>
            <p>Focus on immutability</p>
            <p>Recursion instead of loops</p>
            <br/>
            <p>Typed ML: Haskell, Standard ML, OCaml, F#</p>
            <p>Untyped Lisps: Common Lisp, Scheme, Clojure</p>
            <p>Languages to formalize mathematics are also functional</p>
          </section>
          <section>
            <h2>Haskell</h2>
            <p>Created in 1990 by a group of mathematicians and CS theorists</p>
            <p>Pure functional language</p>
            <p>Statically typed (à la C, C++) but with type inference</p>
            <p>Immutable data structures</p>
            <p>Based on System F (2nd-order typed λ-calculus)</p>
            <p>Relies heavily on category theory</p>
          </section>
          <section><div class='terminal'><pre>λ> 42 + 5
47

λ> (+) 42 5
47

λ> :t 'c'
'c' :: Char

λ> :t 32
32 :: Num p => p

λ> foldr (*) 1 [6, 28, 70, 496, 836]
4876354560

λ> :t map
map :: (a -> b) -> [a] -> [b]

λ> :t (**)
(**) :: Floating a => a -> a -> a
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Bool = False | True</code></pre>

<div class='terminal'><pre>
λ> :t False
False :: Bool
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>type Language = String
data NativeLanguage = None | Unilingual Language | Multilingual (Set Language)
</code></pre>

<div class='terminal'><pre>λ> :t None
None :: NativeLanguage

λ> :t Multilingual
Multilingual :: Set Language -> NativeLanguage

λ> marieCurie = Multilingual (Set.fromList ["Polish", "Russian"])
λ> :t marieCurie
marieCurie :: NativeLanguage
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Maybe a = Nothing | Just a

safeSqrt r = if r < 0 then Nothing else Just (sqrt r)
</code></pre>
<div class='terminal'><pre>
λ> :t safeSqrt
safeSqrt :: (Ord a, Floating a) => a -> Maybe a
λ> :t safeSqrt 0.5
safeSqrt 0.5 :: (Ord a, Floating a) => Maybe a
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Maybe a = Nothing | Just a

realSqrt r :: Double -> Maybe Double
realSqrt r = if r < 0 then Nothing else Just (sqrt r)
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>values = [0.05, 0.01, 0.07, 0.0032, 0.00014]

sumLogs = (+) . log

foldr sumLogs 0 values
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>values = [0.05, 0.01, 0.07, 0.0032, 0.00014]

sumLogs :: (Floating a) => a -> a -> a
sumLogs = (+) . log

answer :: Double
answer = foldr sumLogs 0 values
</code></pre>
          </section>
          <section>
            <h2>Functions have only one argument</h2>
<pre style='font-size:1em;'><code class='haskell'>-- Checks whether 'by' divides 'n' with a remainder of 0.
divides by n = n `mod` by == 0

-- Checks if a number is even
isEven = divides 2 -- Currying
</code></pre>
          </section>
          <section>
            <h2>Functions have only one argument</h2>
<pre style='font-size:1em;'><code class='stretch haskell'>-- Checks whether 'by' divides 'n' with a remainder of 0.
divides :: Integral a => a -> a -> Bool
divides by n = n `mod` by == 0

-- Checks if a number is even.
isEven :: Integral a => a -> Bool
isEven = divides 2

addOne = (+) 1
</code></pre>
          </section>
          <section>
            <h2>Type Theory: Abstraction and Application</h2>
<div class='terminal'><pre>
λ> values = [0.1, 0.4, 0.9, 0.03, 0.0001, 0.8]

λ> map sqrt values
[0.32,0.63,0.95,0.17,0.89]

λ> map (+ 1) values
[1.1,1.4,1.9,1.03,1.0001,1.8]

λ> map (log . sqrt) values
[-1.15,-0.46,-0.0052,-1.75,-4.61,-0.11]

λ> map (\x -> if x < 0.5 then 'a' else 'z') values
"aazaaz"
</pre></div>
          </section>
          <section>
            <h2>Type Theory: Abstraction and Application</h2>
<div class='terminal'><pre>
λ> :t (\x -> if x < 0.5 then 'a' else 'z')
(\x -> if x < 0.5 then 'a' else 'z') :: (Ord a, Fractional a) => a -> Char

λ> (\x -> if x < 0.5 then 'a' else 'z') 0.2
'a'

λ> (\x -> if x < 0.5 then 'a' else 'z') 0.5
'z'
</pre></div>
          </section>
          <section>
<div class='terminal'><pre>
λ> capitalOf = Map.fromList [("Arrakeen", "Arrakis")]
λ> Map.lookup "France" capitals
Nothing

λ> Map.lookup "Arrakis" capitals
Just "Arrakeen"
</pre></div>
          </section>
          <section>
<pre style='font-size:0.95em;'><code class='stretch haskell'>type Graph k e = Map k (Map k e)

getEdge :: (Ord k) => k -> k -> Graph k e -> Maybe e
getEdge head tail g =
  case Map.lookup head g of
    Maybe g' => case Map.lookup tail g' of
                  Maybe edge => edge
                  Nothing    => Nothing
    Nothing => Nothing
</code></pre>
          </section>
          <section>
<pre style='font-size:0.95em;'><code class='stretch haskell'>type Graph k e = Map k (Map k e)

getEdge :: (Ord k) => k -> k -> Graph k e -> Maybe e
getEdge head tail g = Map.lookup head g >>= Map.lookup tail
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='stretch haskell'>class Monad m where
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b        -> m b
  return :: a                 -> m a
  fail   :: String -> m a
</code></pre>
          </section>
          <section>
            <img src='img/lyah.png' alt='lyah'/>
            <p><a href='http://learnyouahaskell.com'>http://learnyouahaskell.com</a></p>
          </section>
          <section>
            <img width='900px' src='img/category-in-context.jpg' alt='context'/>
            <p>Emily Riehl (<a href='https://twitter.com/emilyriehl'>@emilyriehl</a>)</p>
          </section>
          <section>
            <p>λC is a powerful logic (higher-order logic)</p>
            <p>λC is capable of formalizing mathematics (Coq, Lean).</p>
            <p>λC is computationally powerful, it's a rich language for expressing programs.</p>
          </section>
          <section>
            <h2>The case for type theory</h2>
            <p>Can quantify over anything (\(\infty\)-order logic)</p>
            <p>Used for decades to formalize mathematics</p>
            <p>It's a rich logic</p>
            <p>It's a rich foundation for mathematics</p>
            <p>It's a rich foundation for programming languages</p>
          </section>
          <section>
            <h2>The case against type theories (HOL)</h2>
            <p>Arguably easier to use in many cases, but the foundations are conceptually harder to understand</p>
            <p>All implementations are different</p>
            <p>Richer than 0th/1st order logics, and thus inference is harder</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Many-Valued Logics</h2>
          </section>
          <section>
            <h2>Bivalence (0th order fuzziness)</h2>
            \[Truth \in \{False, True\}.\]
            <br/>
            \[Truth \in \{F, T\}.\]
            <br/>
            \[Truth \in \{\bot, \top\}.\]
            <br/>
            \[\{Theory\ x: True\}.\]
          </section>
          <section>
            <h2>A few properties</h2>
            <p>Conjunction and disjunction are commutative, idempotent:</p>
            \[a \land b \equiv b \land a, a \lor b \equiv b \lor a.\]
            \[a \land a \equiv a, b \lor b \equiv b.\]
            <br/>
            <p>De Morgan laws:</p>
            \[a \land b \equiv \neg (\neg a \lor \neg b).\]
            \[a \lor b \equiv \neg (\neg a \land \neg b).\]
            <br/>
            <p>Negation is involutive: \(\neg \neg x \equiv x\).</p>
          </section>
          <section>
            <h2>1st order fuzziness</h2>
            \[\{x \in \mathbb{R}: 0 \leq x \leq 1\}.\]
            <br/>
            \[\{Theory\ x: 0.72918\}.\]
            <br/>
            <p>Viruses are alive: 0.8.</p>
            <p>Wolves prey on rabbits: 0.06.</p>
            <p>1. Nf3 is a good chess opening: 0.94.</p>
            <p>X speaks Korean: 0.86.</p>
            <p>Quebec French = French: 0.95.</p>
          </section>
          <section>
            <h2>Many-valued logic &amp; connectives</h2>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Connective</th>
                <th>Łukasiewicz</th>
                <th>Gödel-Dummett</th>
                <th>Product</th>
              </tr>
              <tr>
                <td>\(x \land y\)</td>
                <td>\(max(0, x + y - 1)\)</td>
                <td>\(min(x, y)\)</td>
                <td>\(x \times y\)</td>
              </tr>
              <tr>
                <td>\(x \lor y\)</td>
                <td>\(min(1, x + y)\)</td>
                <td>\(max(x, y)\)</td>
                <td>\(x + y - x\times y\)</td>
              </tr>
              <tr>
                <td>\(x \Rightarrow y\)</td>
                <td>\(min(1, 1 - x + y)\)</td>
                <td>1 if \(x \leq y\) else \(y\)</td>
                <td>1 if \(x \leq y\) else \(y/x\)</td>
              </tr>
              <tr>
                <td>\(\neg x\)</td>
                <td>\(1 - x\)</td>
                <td>0 if \(x > 0\) else 1</td>
                <td>0 if \(x > 0\) else 1</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Three core fuzzy logics?</h2>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>Mostert–Shields’ theorem shows that a t-norm is continuous if and only if it
              can be built from the previous three ones by the construction of ordinal sum. In
              other words, a t-norm is continuous if and only if it is an ordinal sum of
              Łukasiewicz, Gödel and product t-norms.</p>
            </blockquote>
            <p>Flaminio et al. <i>Towards a probability theory for product logic: States, integral representation and reasoning</i>. doi: 10.1016/j.ijar.2017.11.003.</p>
          </section>
          <section>
            <h2>Properties</h2>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Property</th>
                <th>Łukasiewicz</th>
                <th>Gödel-Dummett</th>
                <th>Product</th>
              </tr>
              <tr>
                <td>Normal</td>
                <td>Yes!</td>
                <td>Yes!</td>
                <td>Yes!</td>
              </tr>
              <tr>
                <td>Idempotent \(\land, \lor\)</td>
                <td><font color='#CE0909'>Nay!</font></td>
                <td>Yes!</td>
                <td><font color='#CE0909'>Nay!</font></td>
              </tr>
              <tr>
                <td>Involutive \(\neg\)</td>
                <td>Yes!</td>
                <td><font color='#CE0909'>Nay!</font></td>
                <td><font color='#CE0909'>Nay!</font></td>
              </tr>
              <tr>
                <td>De Morgan laws</td>
                <td>Yes!</td>
                <td><font color='#CE0909'>Nay!</font></td>
                <td><font color='#CE0909'>Nay!</font></td>
              </tr>
            </table>
          </section>
          <section>
            <img src='img/book-mathfuzzy1.jpg' alt='mathfuzzy1'/>
          </section>
          <section>
            <img src='img/book-fuzzymath.jpg' alt='mathfuzzy1'/>
          </section>
          <section>
            <h2>2nd order fuzziness</h2>
            <p>Interval:</p>
            \[\{\mathbb{x} \in \mathbb{R}^2: 0 \leq x_0 \leq x_1 \leq 1\}.\]
            <br/>
            \[\{Theory\ x: [0.6981, 0.73019]\}.\]
            <br/>
            <p>Generalized:</p>
            \[\{x \in \mathbb{R}: 0 \leq x \leq 1\} \mapsto \{y \in \mathbb{R}: 0 \leq y \leq 1\}.\]
            <br/>
            \[\{\{Theory\ x: 0.25\}: 0.0\}.\]
            \[\{\{Theory\ x: 0.7071\}: 0.65\}.\]
            \[\{\{Theory\ x: 0.73\}: 0.86\}.\]
          </section>
          <section>
            <img src='img/book cover-mendel17.png' alt='mendel17'/>
          </section>
          <section>
            <h2>Pure logic</h2>
            <img src='img/preyon-log.png' alt='log'/>
          </section>
          <section>
            <h2>Probabilistic logic<br/>(à la Markov Logic Networks)</h2>
            <img src='img/preyon-prob.png' alt='prob'/>
          </section>
          <section>
            <h2>Fuzzy Logic</h2>
            <img src='img/preyon-fuzzy1.png' alt='f1'/>
          </section>
          <section>
            <h2>Fuzzy Logic</h2>
            <img src='img/preyon-fuzzy2.png' alt='f2'/>
          </section>
          <section>
            <img src='img/paper-fuzzy-tt.png' alt='fuzzy tt'/>
          </section>
          <section>
            <h2>What to do?</h2>
            <p>Implement fuzzy type theory, more specifically, a fuzzy CoC.</p>
            <p>Model truth as either bivalent OR fuzzy (OR fuzzy2?) to ensure 100% compatibility with existing systems.</p>
            <p>"Core" knowledge would remain bivalent (mostly maths, but also some scientific principles).</p>
            <p>Fuzzy fact could bring data into the mix.</p>
            <p>Would need to reevalute some sections of the knowledge base with new facts.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Higher-Order Probabilistic Programming Languages</h2>
          </section>
          <section>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>[...] ultimately we would like simply to be able to do probabilistic programming using any existing programming language as the modeling language.</p>
            </blockquote>
            <p>From J-W van de Meent et al. <i>An Introduction to Probabilistic Programming</i>, arxiv:1809.10756, 2018.</p>
          </section>
          <section>
            <img src='img/article-lambda-prob.png' alt='lambda prob'/>
          </section>
          <section>
            <img src='img/paper-staton16.png' alt='staton16'/>
          </section>
          <section>
            <h2>Solid Implementations!</h2>
            <p><a href='https://github.com/probprog/anglican'>Anglican</a></p>
            <p><a href='https://github.com/TuringLang/Turing.jl'>Turing.jl</a></p>
            <p><a href='https://pyro.ai/'>Uber's Pyro</a></p>
          </section>
        </section>

      </div>
    </div>

    <script src='reveal.js-3.8.0/js/reveal.js'></script>
    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        width: '80%',
        height: '100%',
        margin: 0,
        minScale: 1,
        maxScale: 1,
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: '',

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        dependencies: [
          { src: 'reveal.js-3.8.0/plugin/highlight/highlight.js', async: true }
        <!--  { src: 'plugin/math/math.js', async: true } -->
        ]
      });
    </script>
    <script type='text/javascript' src='../../js/bower/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
