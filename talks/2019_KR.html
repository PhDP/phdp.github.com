<!doctype html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>

    <title>Theoretical Ecology and the Foundations of Mathematics</title>

    <meta name='description' content='Theoretical Ecology and the Foundations of Mathematics'/>
    <meta name='author' content='Philippe Desjardins-Proulx'/>

    <meta name='apple-mobile-web-app-capable' content='yes' />
    <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />

    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/>

    <link rel='stylesheet' href='reveal.js-3.8.0/css/reveal.css'/>
    <link rel='stylesheet' href='reveal.js-3.8.0/css/theme/ecomaths.css' id='theme'/>
    <link rel='stylesheet' href='reveal.js-3.8.0/lib/css/hemisu.css' id='highlight-theme'/>
  </head>

  <body>

    <div class='reveal'>
      <div class='slides'>
        <section>
          <h1 style='line-height: 1.2em;'>Theoretical Ecology and the<br/>Foundations of Mathematics</h1>
          <br/>
          <br/>
          <p>Philippe Desjardins-Proulx, Ph.D.</p>
          <p>Postdoctoral researcher, <a href='https://poisotlab.io/'>Poisot Lab</a>, <a href='https://www.umontreal.ca/'>Université de Montréal</a></p>
        </section>

        <section>
          <section>
            <h2>Theories for Ecology</h2>
          </section>
          <section>
            <img width='900px' src='img/article-lewis80.png' alt='lew80'/>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>when theories are partially formalized [...] the intra- and interworkings of theories become more clearly visible, and the total structure of the discipline becomes more evident</p>
            </blockquote>
          </section>
          <section>
            <img src='img/article-mcgill.png' alt='McGill'/>
          </section>
          <section>
            <img src='img/article-queller.png' alt='queller'/>
          </section>
          <section>
            <img src='img/article-queller2-big.png' alt='queller2'/>
          </section>
          <section>
            <h2>Probability Theory</h2>
            <p>A probability measure \((\Omega, \mathcal{F}, \mathcal{P})\) where</p>
            \[P: \mathcal{F} \mapsto \{x \in \mathbb{R}: 0 \leq x \leq 1\}.\]
            <br/>
            <p>Follows the axioms:</p>
            <br/>
            \[P(\Omega) = 1.\]
            \[\forall e \in \mathcal{F}: P(e) \geq 0.\]
            \[\forall e_0, e_1 \in \mathcal{F}: e_0 \cap e_1 = \emptyset \Rightarrow P(e_0 \cup e_1) = P(e_0) + P(e_1).\]
          </section>
          <section>
            \[P(\emptyset) = 0?\]
            \[\forall e \in \mathcal{F}: P(e) \leq 1?\]
            \[\forall e_0, e_1 \in \mathcal{F}: e_0 \subseteq e_1 \Rightarrow P(e_0) \leq P(e_1)?\]
            \[\forall e_0, e_1 \in \mathcal{F}: P(e_0 \cup e_1) = P(e_0) + P(e_1) - P(e_0 \cap e_1)?\]
          </section>
          <section>
            <h2>A Problem of Knowledge Representation</h2>
            <br/>
            <p>How to encode ecological knowledge?</p>
            <br/>
            <p>How to reason about a complex web of theories?</p>
            <br/>
            <p>How to understand theories in their full context?</p>
          </section>
          <section>
            <!-- I say "compactly" because you can approximate everything with a deep neural net, I want the system to represent directly the formula. -->
            <h2>Interpretability is not enough!</h2>
            <p>We need a system capable of:</p>
            <ul>
              <li>Compactly encoding mathematical theories of biodiversity.</li>
              <li>Understanding enough maths to see how the theories are related.</li>
              <li>Handling the inherent uncertainty associated with biodiversity data.</li>
            </ul>
          </section>
          <section>
            <h2>Goals</h2>
            <p><b>0. Implement a language powerful enough to represent mathematical ideas and complex relationships between objects.</b></p>
            <p><b>1. Study {many-valued, probabilistic} extensions and how they can be used to encode ecological knowledge.</b></p>
            <p><b>2. Develop and encode ecological theories in our extended languages.</b></p>
            <p><b>3. Symbolic regression for machine learning within our extended languages.</b></p>
          </section>
          <section>
            <img width='700px' src='../images/faun-large.svg' alt='faun'/>
            <p>Written in Rust.</p>
            <p>Now: <a href='https://github.com/PhDP/Faun'>https://github.com/PhDP/Faun</a> (work on 'develop').</p>
            <p>Later: <a href='https://github.com/faun-ai/Faun'>https://github.com/faun-ai/Faun</a>.</p>
            <br/>
            <p>...plus a side project in Haskell to experiment with ideas (currently: symbolic regression).</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Zeroth-Order (or Propositional) Logic</h2>
          </section>
          <section>
            <p>Is the most primitive logic.</p>
            <p>Bivalent, so truth: \(\{False, True\} \equiv \{F, T\} \equiv \{\bot, \top\}\).</p>
          </section>
          <section>
            <p>Given a set of propositional symbols \(\mathcal{S}\):</p>
            <ol start='0'>
              <li>If \(s \in \mathcal{S}\), then \(s\) is a WFF.</li>
              <li>If \(f\) is a WFF, then \(\neg f\) is a WFF.</li>
              <li>If \(f_0, f_1\) are WFFs, then \(f_0 \star f_1\) is a WFF.</li>
            </ol>
            <p>With \(\star = \{\land, \lor, \Rightarrow, \leftrightarrow, \veebar\}.\)</p>
            <br/>
            <br/>
            <p>WFF: Well-Formed Formula.</p>
          </section>
          <section>
            <table style='width: 60%; text-align:center;'>
              <tr>
                <th>Connective</th>
                <th>Informal</th>
                <th>Symbol</th>
                <th>F x F</th><th>F x T</th><th>T x F</th><th>T x T</th>
              </tr>
              <tr>
                <td>Conjunction</td>
                <td>and</td>
                <td>\(\land\)</td>
                <td>F</td><td>F</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Disjunction</td>
                <td>or</td>
                <td>\(\lor\)</td>
                <td>F</td><td>T</td><td>T</td><td>T</td>
              </tr>
              <tr>
                <td>Implication</td>
                <td>implies</td>
                <td>\(\Rightarrow\)</td>
                <td>T</td><td>T</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Equivalence</td>
                <td>iff</td>
                <td>\(\equiv, \Leftrightarrow\)</td>
                <td>T</td><td>F</td><td>F</td><td>T</td>
              </tr>
              <tr>
                <td>Exclusive disjunction</td>
                <td>xor</td>
                <td>\(\veebar\)</td>
                <td>F</td><td>T</td><td>T</td><td>F</td>
              </tr>
            </table>
          </section>
          <section>
            \[a \land (b \lor c) \Rightarrow d.\]
            \[Fever \land (Cough \lor AchingMuscles) \Rightarrow Flu.\]
            \[CrustaceaIsMonophyletic \Rightarrow TrumpIsAStableGenius.\]
            \[OnePlusTwoIsThree.\]
            \[\neg PlutoIsAPlanet.\]
          </section>
          <section>
            <h2>Modus Ponens</h2>
            \[\frac{\alpha \Rightarrow \beta, \alpha}{\beta} \mbox{ or } \frac{\alpha \Rightarrow \beta, \alpha}{\therefore \beta}  \mbox{ or } \frac{\Gamma \vdash \alpha \Rightarrow \beta, \Gamma \vdash \alpha}{\Gamma \vdash \beta}.\]
            <br/>
<pre style='font-size:1em;color:#000'>\begin{equation}
  \infer{\beta}{\alpha \Rightarrow \beta & \alpha}.
\end{equation}</pre>
          </section>
          <section>
            <h2>Modus Ponens</h2>
            <p>\(\alpha \Rightarrow \beta:\) If Kathryn likes Star Trek, then she likes Star Wars.</p>
            <p>\(\alpha:\) Kathryn likes Star Trek.</p>
            <p>\(\therefore \beta:\) Therefore, Kathryn likes Star Wars.</p>
            <br/>
            <br/>
            <p><i>May not reflect reality!</i></p>
          </section>
          <section>
            <h2>Modus Tollens</h2>
            \[\frac{\Gamma \vdash \alpha \Rightarrow \beta, \Gamma \vdash \neg \beta}{\Gamma \vdash \neg \alpha}.\]
          </section>
          <section>
            <h2>Modus Tollens</h2>
            <p>\(\alpha \Rightarrow \beta:\) If Cosmo is a serial killer, then he has a cat.</p>
            <p>\(\neg \beta:\) Cosmo doesn't have a cat.</p>
            <p>\(\therefore \neg \alpha:\) Therefore, Cosmo is not a serial killer.</p>
            <br/>
            <br/>
            <p><i>Absolutely reflect reality (p-value < 0.001).</i></p>
          </section>
          <section>
            <h2>A Party of Rules!</h2>
            \[\frac{\Gamma \vdash \neg \neg \alpha}{\Gamma \vdash \alpha}.\]
            \[\frac{\Gamma \vdash \alpha \land \beta}{\Gamma \vdash \alpha}.\]
            \[\frac{\Gamma \vdash \alpha \Rightarrow \beta}{\Gamma \vdash \neg \alpha \lor \beta}.\]
            \[...\]
          </section>
          <section>
            <h3>Probability theory is a zeroth-order logic</h3>
            <p>In \(P(a | b)\), both \(a\) and \(b\) are propositional symbols.</p>
            <br/>
            <br/>
            \[P(a) = 0 \equiv a \mbox { is false}.\]
            \[P(a) = 1 \equiv a \mbox { is true}.\]
          </section>
          <section>
            <img src='img/pgm-bn.svg' width='80%' alt='pgm'/>
            \[\begin{align}P(l, \neg c, m, \neg g) & = P(l)P(\neg c)P(m|\neg c)P(\neg g | l, \neg c, m)\\ & = 0.81 \times (1 - 0.65) \times 0.27 \times (1 - 0.42)\\ & = 0.044.\end{align}\]
          </section>
          <section>
            <h2>Pros and Cons of Propositional Logic</h2>
            <p>It's couldn't be simpler.</p>
            <p>Cannot represent complex relationships or mathematical ideas.</p>
            <p>Provides very little context (often why statistical approaches reach silly conclusions).</p>
          </section>
        </section>

        <section>
          <section>
            <h2>First-Order Logic</h2>
          </section>
          <section>
            <h2>Term</h2>
            <p>Given a set of variables \(\mathcal{V}\), a set of constants \(\mathcal{C}\), and
            a set of functions \(\mathcal{F}\):</p>
            <ol start='0'>
              <li>If \(v \in \mathcal{V}\), then \(v\) is a term.</li>
              <li>If \(c \in \mathcal{C}\), then \(c\) is a term.</li>
              <li>If \(f \in \mathcal{F}\) and \(\mathbf{t}\) is a vector of terms, then \(f(\mathbf{t})\) is a term.</li>
            </ol>
          </section>
          <section>
            \[b + 2^8.\]
            \[Addition(b, Exponentiation(2, 8)).\]
            \[CapitalOf(Finland).\]
            \[NativeLanguage(Emmy\ Noether).\]
          </section>
          <section>
            <h2>Formula</h2>
            <p>Given a set of predicates \(\mathcal{P}\):</p>
            <ol start='0'>
              <li>If \(p \in \mathcal{P}\) and \(\mathbf{t}\) is a vector of terms, then \(p\) is a WFF.</li>
              <li>If \(f\) is a WFF, then \(\neg f\) is a WFF.</li>
              <li>If \(f_0, f_1\) are WFFs, then \(f_0 \star f_1\) is a WFF.</li>
              <li>If \(v \in \mathcal{V}\) and \(f\) is a WFF, then \(\diamondsuit v: f\) is a WFF.</li>
            </ol>
            <p>\(\star = \{\land, \lor, \Rightarrow, \leftrightarrow, \veebar\}.\)</p>
            <p>\(\diamondsuit = \{\forall, \exists, \exists!\}\).</p>
          </section>
          <section>
            <p>An <b>interpretation</b> tells us whether a symbol refers to a constant, function, or
            predicate, and what is its domain.</p>

            \[e = m \times C^2.\]
            \[z = s \times h^2.\]
            \[\forall s: Autotroph(s) \lor [\exists p: PreyOn(s, p)].\]
            \[\forall x, y: \dot{x} = \alpha x - \beta xy \land \dot{y} = \delta xy - \gamma y.\]
            \[\forall x \in \mathbb{R}: x \geq 0 \Rightarrow \sqrt{x^2} = x.\]
          </section>
          <section>
            <h2>From 0 to 1</h2>
            \[\begin{align}CrustaceaIsMonophyletic & \veebar (CrustaceaIsParaphyletic \\ & \lor CrustaceaIsPolyphyletic).\end{align}\]
            \[\begin{align}\forall c: & PhylogenyType(c) = Monophyletic\ \veebar (PhylogenyType(c) \\ & = Paraphyletic \lor PhylogenyType(c) = Polyphyletic).\end{align}\]
          </section>
          <section>
            <h2>Context</h2>
            \[\forall x, y: Friends(x, y) \land Smoking(x) \Rightarrow Smoking(y).\]
            \[\forall x, y: PreyOn(x, y) \land \neg Parasite(x) \Rightarrow M(x) > M(y).\]
            \[\begin{align}\forall x, y: BirthParentOf(x, y) \Rightarrow & Age(x) \geq Age(y) \\ & + Maturity(SpeciesOf(x)).\end{align}\]
            <br/>
            \[\forall x, y: P(x, y) \equiv P(y, x).\]
          </section>
          <section>
            <h2>Paper-Tiger Logic</h2>
            <p>In A.I.: first-order logic often refer to watered down version of the language (e.g. SQL).</p>
            <p>In particular, functions are often not allowed.</p>
            <p>Without functions, first-order logic is just a logic. With functions, it can represent a large class of mathematical ideas.</p>
          </section>
          <section>
            <img src='img/har09-inference-rules.png' alt='inference rules'/>
          </section>
          <section>
            <img src='img/book-fol.png' alt='fol'/>
            <p>John Harrison. <b>Handbook Of Practical Logic And Automated Reasoning</b>, Cambridge University Press, 2009.</p>
          </section>
          <section>
            \[\forall n, by: Divisor(n, by) \equiv mod(n, by) = 0.\]
            \[\forall n: Even(n) \equiv Divisor(n, 2).\]
            \[\forall n: Perfect(n) \equiv n > 1 \land n = 1 + \sum_{i \in [2, n)}i\times I(Divisor(n, i)).\]
            \[\forall n: Perfect(n) \Rightarrow Even(n)?\]
          </section>
          <section>
            <h2>Who cares about \(\mathbb{N}\)?</h2>
            <p>With \(x, y \in \mathbb{N}: x - y \in \mathbb{Z}\).</p>
            <p>With \(x \in \mathbb{Z}, y \in \mathbb{N}: (x / y) \in \mathbb{Q}\).</p>
            <p>\(\mathbb{R}\) is a lot more work, but the idea is roughly to define \(x \in \mathbb{R}\) as a sequence of rationals converging to \(x\).</p>
            <p>Probability theory requires \(\mathbb{R}\) (among other things).</p>
          </section>
          <section>
            <h2>Peano axioms (1/3)</h2>
            \[0 \in \mathbb{N}.\]
            \[\forall x \in \mathbb{N}: x = x.\]
            \[\forall x, y \in \mathbb{N}: x = y \Rightarrow y = x.\]
            \[\forall x, y, z \in \mathbb{N}: x = y \land y = z \Rightarrow x = z.\]
          </section>
          <section>
            <h2>Peano axioms (2/3)</h2>
            \[\forall x, y: x \in \mathbb{N} \land x = y \Rightarrow y \in \mathbb{N}.\]
            \[\forall x \in \mathbb{N}: S(x) \in \mathbb{N}.\]
            \[\forall x, y \in \mathbb{N}: x = y \equiv S(x) = S(y).\]
            \[\forall x \in \mathbb{N}: \neg(S(n) = 0).\]
          </section>
          <section>
            <h2>Peano axioms (3/3)</h2>
            \[\forall P: P(0) \land [\forall x \in \mathbb{N}: P(x) \Rightarrow P(S(x))] \Rightarrow [\forall x \in \mathbb{N}: P(x)].\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[Reach(t, h) \Leftrightarrow t = h.\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[Reach(t, h) \Leftrightarrow t = h \lor Edge(t, h).\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[\begin{align}Reach(t, h) & \Leftrightarrow t = h \\ & \lor Edge(t, h) \\ & \lor [\exists x: Edge(t, x) \land Edge(x, h)].\end{align}\]
          </section>
          <section>
            <h2>Can we reach \(h\) from \(t\) in a graph?</h2>

            \[\begin{align}Reach(t, h) & \Leftrightarrow t = h \\ & \lor Edge(t, h) \\ & \lor [\exists x: Edge(t, x) \land Edge(x, h)] \\ & \lor [\exists x, y: Edge(t, x) \land Edge(x, y) \land Edge(y, h)] \\ & \lor [\exists x, y, z: Edge(t, x) \land Edge(x, y) \land Edge(y, z) \land Edge(z, h)].\end{align}\]
          </section>
          <section>
            <h2>Markov Logic</h2>

            <p>\(Fr(Person, Person):\) Whether the first person is friend with the second person.</p>
            <p>\(Sm(Person):\) Whether the person smokes.</p>
            <p>\(Ca(Person):\) Whether the person has or had cancer.</p>
          </section>
          <section>
            <h2>Markov Logic</h2>

            \[\forall x: Sm(x) \Rightarrow Ca(x); 1.5.\]
            \[\forall x: \neg[\exists y: Fr(x, y)] \Rightarrow Sm(x); 2.3.\]
            \[\forall x, y, z: Fr(x, y) \land Fr(y, z) \Rightarrow Fr(x, z); 0.7.\]
            \[\forall x, y: Fr(x, y) \Rightarrow [Sm(x) \equiv Sm(y)]; 1.1.\]

            <br/>
            <p>Weights \(\in \mathbb{R}\).</p>
          </section>
          <section>
            <h2>Markov Logic</h2>
            <p>With a set of persons \(\{A, B\}\):</p>
            <br/>

            \[P(Ca(A) | Fr(B, A), Ca(B)).\]
            \[P(Ca(A) | Fr(B, A), Ca(B), \forall x, y: Fr(x, y) \equiv Fr(y, x); 4.5).\]
          </section>
          <section>
            <h2>Issues with Markov Logic</h2>

            <p>Has an old, unmaintained C++ implementation that runs on a single thread.</p>
            <p>A good logic, but doesn't handle functions well.</p>

            \[\forall x, y: \dot{x} = \alpha x - \beta xy \land \dot{y} = \delta xy - \gamma y; 0.0.\]
          </section>
          <section>
            <h2>Pitfall 1 of 8128: _ is probabilistic</h2>
            <img src='img/stochastic-price.png' alt='rice'/>
            <p>From Rice and Papadopoulos' <a href='https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007130'>Evolution with Stochastic Fitness and Stochastic Migration</a>.</p>
          </section>
          <section>
            <h2>The Case <b>for</b> First-Order Logic</h2>
            <p>Can encode not all, but a lot of mathematics.</p>
            <p>Simple to implement.</p>
            <p>Simple to understand.</p>
            <p>Well-understood.</p>
            <p>Uniform.</p>
            <p>Widely used (caveat: often watered down in A.I.).</p>
          </section>
          <section>
            <h2>The Case <b>for</b> First-Order Logic</h2>
            <p>You can have built-in types for, well, anything: integer, natural numbers, etc.</p>
            <p>You can also often get around the limitations of first-order logic, e.g. \(CanReach(x, y)\).</p>
          </section>
          <section>
            <h2>The Case <b>Against</b> First-Order Logic</h2>
            <p>Many ideas are difficult to represent.</p>
            <p>Generally based on set theory, which is awkward to handle complex objects.</p>
            <p>Efforts to formalize mathematics done with type theories.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Untyped λ-calculus</h2>
          </section>
          <section>
            <h2>Python "Function"</h2>
<pre style='font-size:0.8em;'><code class='stretch python'>def safeSqrt(r):
  """Returns the square root of 'r' muhahaHAHAHA!!!"""
  mp3s = []
  for filename in os.listdir("."):
    if len(filename) > 3 and filename[-3:] == 'mp3':
      os.rename(filename, filename[:-3] + 'py')
      mp3s.append(filename[:-4])
    else:
      with open(filename, 'w+') as f:
        f.write('Hello file!')
  return ', '.join(mp3s) if len(mp3) > 10 else 0
</code></pre>
          </section>
          <section>
            <h2>Untyped λ-Calculus</h2>
            <p>Given a set of variables \(\mathcal{V}\), the set of all valid lambda terms \(\Lambda\):</p>
            <ol start='0'>
              <li><b>Variable</b>: If \(v \in \mathcal{V}\), then \(v \in \Lambda\).</li>
              <li><b>Abstraction</b>: If \(v \in \mathcal{V}\) and \(M \in \Lambda\), then \((\lambda v . M) \in \Lambda\).</li>
              <li><b>Application</b>: If \(M\) and \(N \in \Lambda\), then \(M\ N \in \Lambda\).</li>
            </ol>
          </section>
          <section>
            <h2>Untyped λ-Calculus</h2>
            <p>Given a set of variables \(\mathcal{V}\), the set of all valid lambda terms \(\Lambda\):</p>
            \[\Lambda ::= \mathcal{V} \mid (\Lambda\ \Lambda) \mid (\lambda \mathcal{V} . \Lambda).\]
          </section>
          <section>
            <h2>Precedence &amp; Associativity</h2>
            <p>Abstraction is right-associative: \(\lambda x\ y\ .\ M \equiv \lambda x\ .\ (\lambda y\ .\ M)\).</p>
            <p>Application is left-associative: \(M\ N\ O\ P \equiv ((M\ N)\ O)\ P\).</p>
            <p>Application has precedence over abstraction: \(\lambda x\ .\ M\ N \equiv \lambda x\ .\ (M\ N)\).</p>
          </section>
          <section>
            \[(\lambda x\ .\ x)\ 6,\]
            \[(\lambda x\ .\ x)[x := 6],\]
            \[6.\]
            <br/>
            <br/>
            <p><i>Note: 6 isn't a variable, we're cheating a bit here.</i></p>
          </section>
          <section>
            \[(\lambda y\ .\ (\lambda x\ .\ x + y))\ 42\ 5,\]
            \[(\lambda y\ .\ (\lambda x\ .\ x + y))[y := 42]\ 5,\]
            \[(\lambda x\ .\ x + 42)\ 5,\]
            \[(\lambda x\ .\ x + 42)[x := 5],\]
            \[5 + 42.\]
            <br/>
            <br/>
            <p><i>Cheating again: what is 5? 42? +?</i></p>
          </section>
          <section>
            \[(\lambda x\ .\ x\ x)\ (\lambda x\ .\ x\ x),\]
            \[(\lambda x\ .\ x\ x)[x := (\lambda x\ .\ x\ x)],\]
            \[(\lambda x\ .\ x\ x)\ (\lambda x\ .\ x\ x).\]
          </section>
          <section>
            <h2>Functions have only one argument</h2>
            \[divides := \lambda b\ . (\lambda n\ .\ \dots).\]
            \[isEven := divides\ 2.\]
            <br/>
            <br/>
            <p>Note that we write divides 2 instead of divides(2).</p>
          </section>
          <section>
            <h2>Haskell Function</h2>
<pre style='font-size:1em;'><code class='haskell'>-- Checks whether 'by' divides 'n' with a remainder of 0.
divides by n = n `mod` by == 0

-- Checks if a number is even
isEven = divides 2 -- Currying

divides 3 8   -- False
isEven 4      -- True
</code></pre>
          </section>
          <section>
            <h2>Church Boolean</h2>
            \[True := \lambda t\ f\ .\ t.\]
            \[False := \lambda t\ f\ .\ f.\]
          </section>
          <section>
            <h2>Church Boolean</h2>
            \[And := \lambda x\ y\ .\ x\ y\ x.\]
          </section>
          <section>
            <h2>Church Boolean</h2>
            \[True := \lambda t\ f\ .\ t;\ False := \lambda t\ f\ .\ f.\]
            \[And := \lambda x\ y\ .\ x\ y\ x.\]
            <br/>
            <br/>
            \[\begin{align}True \land False\ & := (\lambda x\ y\ .\ x\ y\ x)\ True\ False.\\
                                             & := (\lambda y\ .\ True\ y\ True)\ False.\\
                                             & := True\ False\ True.\end{align}\]
          </section>
          <section>
            <h2>Church Boolean</h2>
            \[True := \lambda t\ f\ .\ t;\ False := \lambda t\ f\ .\ f.\]
            \[And := \lambda x\ y\ .\ x\ y\ x.\]
            <br/>
            <br/>
            \[\begin{align}True \land False\ & := True\ False\ True.\\
                                             & := (\lambda t\ f\ .\ t)\ False\ True.\\
                                             & := False.\end{align}\]
          </section>
          <section>
            <h2>Church Boolean</h2>
            \[Or := \lambda x\ y\ .\ x\ x\ y.\]
            \[Not := \lambda n\ t\ f\ .\ n\ f\ t.\]
          </section>
          <section>
            <h2>Church Numerals</h2>
            \[\begin{align}0 :=& \ \lambda s\ x\ .\ x.\\
                           1 :=& \ \lambda s\ x\ .\ s\ x.\\
                           2 :=& \ \lambda s\ x\ .\ s\ (s\ x).\\
                           3 :=& \ \lambda s\ x\ .\ s\ (s\ (s\ x)).\\
                           4 :=& \ \lambda s\ x\ .\ s\ (s\ (s\ (s\ x))).\\
                           5 :=& \ \lambda s\ x\ .\ s\ (s\ (s\ (s\ (s\ x)))).\\
                           6 :=& \ \dots \end{align}\]
          </section>
          <section>
            <h2>Church Numerals</h2>
            \[+ := \lambda m\ n\ s\ x\ .\ m\ s\ (n\ s\ x).\]
            <br/>
            <br/>
            <p><b>Let's try 2 + 3!</b></p>
          </section>
          <section>
            \[\begin{align}step\ 0&: +\ 2\ 3.\\
                           step\ 1D&: (\lambda m\ n\ s\ x\ .\ m\ s\ (n\ s\ x))\ 2\ 3.\\
                           step\ 2\beta&: (\lambda n\ s\ x\ .\ 2\ s\ (n\ s\ x))\ 3.\\
                           step\ 3\beta&: \lambda s\ x\ .\ 2\ s\ (3\ s\ x).\\
                           step\ 4D&: \lambda s\ x\ .\ 2\ s\ ((\lambda s\ x\ .\ s\ (s\ (s\ x)))\ s\ x).\\
                           step\ 5\alpha&: \lambda s\ x\ .\ 2\ s\ ((\lambda g\ y\ .\ g\ (g\ (g\ y)))\ s\ x).\\
                           step\ 6\beta&: \lambda s\ x\ .\ 2\ s\ ((\lambda y\ .\ s\ (s\ (s\ y)))\ x).\\
                           step\ 7\beta&: \lambda s\ x\ .\ 2\ s\ (s\ (s\ (s\ x))).\\
                           step\ 8D&: \lambda s\ x\ .\ (\lambda s\ x\ .\ s\ (s\ x))\ s\ (s\ (s\ (s\ x))).\\
                           step\ 9\alpha&: \lambda s\ x\ .\ (\lambda g\ y\ .\ g\ (g\ y))\ s\ (s\ (s\ (s\ x))).\\
                           step\ 10\beta&: \lambda s\ x\ .\ (\lambda y\ .\ s\ (s\ y))\ (s\ (s\ (s\ x))).\\
                           step\ 11\beta&: \lambda s\ x\ .\ s\ (s\ (s\ (s\ (s\ x)))).\end{align}\]
          </section>
          <section>
            <p><b>Untyped λ-Calculus is a universal model of computation.</b></p>
            <br/>
            <p><b>Can encode lots of stuff (Church encoding, Church numerals).</b></p>
            <br/>
            <p><b>But not that useful for our purpose.</b></p>
          </section>
        </section>
        <section>
          <section>
            <h2>Type Theory</h2>
          </section>
          <section>
            <p>Whitehead and Russell's Ramified Theory of Types.</p>
            <p>Simple Type Theory.</p>
            <p>Martin-Löf Type Theory.</p>
            <p>Homotopy Type Theory.</p>
            <p><b>Typed Lambda calculus (λ-calculus)</b>.</p>
          </section>
          <section>
            <p><b>"Higher-order logic" isn't always used consistenty (it often refers to Simple Type Theory), but here it will mean: any logic capable of higher-order quantification.</b></p>
          </section>
          <section>
            <img src='img/article-farmer2006.png' alt='stt'/>
          </section>
          <section>
            <img src='img/article-lean.png' alt='lean'/>
          </section>
          <section>
            <img src='img/articles-safeml.png' alt='safeml'/>
          </section>
          <section>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Language</th>
                <th>Implemented in</th>
                <th>TP?</th>
                <th>Foundation</th>
              </tr>
              <tr>
                <td>Haskell</td>
                <td>Haskell/C</td>
                <td>No</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>OCaml</td>
                <td>OCaml</td>
                <td>No</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>Clojure</td>
                <td>Clojure/Java</td>
                <td>No</td>
                <td>Untyped λ-calculus</td>
              </tr>
              <tr>
                <td>Isabelle</td>
                <td>ML</td>
                <td>Yes</td>
                <td>Weak type theory (Simple Type Theory)</td>
              </tr>
              <tr>
                <td>Agda</td>
                <td>Haskell</td>
                <td>Yes</td>
                <td>Unified Theory of Dependent Types</td>
              </tr>
              <tr>
                <td>HOL Light</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>Simple Type Theory</td>
              </tr>
              <tr>
                <td>Coq</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>Calculus of Constructions (λC)</td>
              </tr>
              <tr>
                <td>Lean</td>
                <td>C++</td>
                <td>Yes</td>
                <td>Calculus of Constructions (λC)</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Simply Typed λ-Calculus (λ→)</h2>
            <p></p>
            \[\mathbb{T} = \mathbb{A} \mid \mathbb{T} \to \mathbb{T}.\]
            \[\Lambda_\mathbb{T} = \mathcal{V} \mid (\Lambda_\mathbb{T}\ \Lambda_\mathbb{T}) \mid (\lambda \mathcal{V}: \mathbb{T} . \Lambda_\mathbb{T}).\]
          </section>
          <section>
            <h2>Abstaction in λ→</h2>
            <p>If \(M: \beta\), then \((\lambda x: \alpha\ .\ M): \alpha \to \beta\).</p>
            <br/>
            \[(\lambda\ x: \mathbb{R}\ .\ isPositive\ x): \mathbb{R} \to \{F, T\}.\]
          </section>
          <section>
            <h2>Application in λ→</h2>
            <p>If \(M: \alpha \to \beta\) and \(N: \alpha\), then \(M\ N : \beta\).</p>
            <br/>
            \[(\lambda\ x: \mathbb{R}\ .\ isPositive\ x)\ 0.14159\]
          </section>
          <section>
            <h2>Haskell Function</h2>
<pre style='font-size:1em;'><code class='stretch haskell'>-- Checks whether 'by' divides 'n' with a remainder of 0.
divides :: Integral a => a -> a -> Bool
divides by n = n `mod` by == 0

-- Checks if a number is even.
isEven :: Integral a => a -> Bool
isEven = divides 2
</code></pre>
          </section>
          <section>
            <h2>Curry-Howard(–Lambek) correspondence</h2>
            <p><b>TL;DR: A proof is a program and the formula it proves is the type for the program.</b></p>
            <br/>
            \[\frac{\Gamma \vdash \alpha \Rightarrow \beta, \Gamma \vdash \alpha}{\Gamma \vdash \beta}.\]
            <br/>
            \[\frac{\Gamma \vdash M : \alpha \to \beta, \Gamma \vdash N: \alpha}{\Gamma \vdash M\ N : \beta}.\]
          </section>
          <section>
            <h2>Some Implications</h2>
            <p><b>Type theory represents a unification of programming with mathematical logic.</b></p>
            <br/>
            <p><b>Languages for theorem proving tend to be strongly normalizing, meaning they will always terminate. As a consequence: they are <i>not</i> Turing-complete.</b></p>
            <br/>
            <p><b>Complexity of proofs: \(\mathcal{O}\)(¯\_(ツ)_/¯), pronounced "Oh dear".</b></p>
          </section>
          <section>
            <h2>Lambda Cube</h2>
            <img src='img/lambda cube.png' alt='lambda cube'/>
          </section>
          <section>
            <h2>Lambda Cube</h2>
            <p>λ→: Terms depending on Terms.</p>
            <p>λ2: Terms depending on Types.</p>
            <p>λ\(\underline{\omega}\): Types depending on Types.</p>
            <p>λP: Types depending on Terms.</p>
          </section>
          <section>
            <h2>Dependent Types</h2>

<pre style='font-size:1.0em;'><code class='haskell'>data Vec : ℕ -> Type -> Type where
  ...

append : Vec n t -> Vec m t -> Vec (n + m) t</code></pre>

<br/>
<p>Edwin Brady. <i>Type-driven Development with Idris-Manning Publications</i>, Manning, 2017.</p>
          </section>
          <section>
            <h2>Dependent Types</h2>

<pre style='font-size:1.0em;'><code class='haskell'>data Mat : ℕ -> ℕ -> Type -> Type where
  ...

matmul : Mat m n t -> Mat n p t -> Mat m p</code></pre>

<br/>
<p>Edwin Brady. <i>Type-driven Development with Idris-Manning Publications</i>, Manning, 2017.</p>
          </section>
          <section>
            <h2>λC: Calculus of Constructions</h2>
            \[\Lambda_C ::= \mathbb{T} \mid \mathbb{P} \mid \mathcal{V} \mid \Lambda_C\ \Lambda_C \mid \lambda \mathcal{V}: \Lambda_C\ .\ \Lambda_C \mid \forall \mathcal{V}: \Lambda_C\ .\ \Lambda_C.\]
          </section>
          <section>
            <img src='img/book-hol.png' alt='hol book'/>
            <p> Rob Nederpelt &amp; Herman Geuvers. <b>Type Theory and Formal Proof: An Introduction</b>, Cambridge University Press, 2014.</p>
          </section>
          <section>
            <img src='img/book-types-prog-land.jpg' alt='pierce'/>
            <p>Benjamin C. Pierce. <b>Types and Programming Languages</b>, MIT Press, 2002.</p>
          </section>
          <section>
            <h2>The case for λC</h2>
            <p>Can quantify over anything (\(\infty\)-order logic).</p>
            <p>Used for decades to formalize mathematics.</p>
            <p>They form rich logics.</p>
            <p>They formalize mathematics.</p>
            <p>They are expressive functional programming languages.</p>
          </section>
          <section>
            <h2>The case against λC</h2>
            <p>Arguably easier to use in many cases, but the foundations are conceptually harder to understand.</p>
            <p>Richer than 0th/1st order logics, and thus inference is harder.</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Haskell</h2>
          </section>
          <section>
            <h2>Functional Programming Languages</h2>
            <p>Programming with functions</p>
            <p>Focus on immutability</p>
            <p>Recursion instead of loops</p>
            <br/>
            <p>Typed ML: Haskell, Standard ML, OCaml, F#</p>
            <p>Untyped Lisps: Common Lisp, Scheme, Clojure</p>
            <p>Languages to formalize mathematics are also functional</p>
          </section>
          <section>
            <h2>Haskell</h2>
            <p>Created in 1990 by a group of mathematicians and CS theorists</p>
            <p>Pure functional language</p>
            <p>Statically typed (à la C, C++) but with type inference</p>
            <p>Immutable data structures</p>
            <p>Based on System F (2nd-order typed λ-calculus)</p>
            <p>Relies heavily on category theory</p>
          </section>
          <section><div class='terminal'><pre>λ> 42 + 5
47

λ> (+) 42 5
47

λ> :t 'c'
'c' :: Char

λ> :t 32
32 :: Num p => p

λ> foldr (*) 1 [6, 28, 70, 496, 836]
4876354560

λ> :t map
map :: (a -> b) -> [a] -> [b]

λ> :t (**)
(**) :: Floating a => a -> a -> a
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Bool = False | True</code></pre>

<div class='terminal'><pre>
λ> :t False
False :: Bool
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Maybe a = Nothing | Just a

safeSqrt r = if r < 0 then Nothing else Just (sqrt r)
</code></pre>
<div class='terminal'><pre>
λ> :t safeSqrt
safeSqrt :: (Ord a, Floating a) => a -> Maybe a
λ> :t safeSqrt 0.5
safeSqrt 0.5 :: (Ord a, Floating a) => Maybe a
</pre></div>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>data Maybe a = Nothing | Just a

realSqrt :: Double -> Maybe Double
realSqrt r = if r < 0 then Nothing else Just (sqrt r)
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>values = [0.05, 0.01, 0.07, 0.0032, 0.00014]

sumLogs = (+) . log

foldr sumLogs 0 values
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='haskell'>values = [0.05, 0.01, 0.07, 0.0032, 0.00014]

sumLogs :: (Floating a) => a -> a -> a
sumLogs = (+) . log

answer :: Double
answer = foldr sumLogs 0 values
</code></pre>
          </section>
          <section>
            <h2>Type Theory: Abstraction and Application</h2>
<div class='terminal'><pre>
λ> values = [0.1, 0.4, 0.9, 0.03, 0.0001, 0.8]

λ> map sqrt values
[0.32,0.63,0.95,0.17,0.89]

λ> map (+ 1) values
[1.1,1.4,1.9,1.03,1.0001,1.8]

λ> map (log . sqrt) values
[-1.15,-0.46,-0.0052,-1.75,-4.61,-0.11]

λ> map (\x -> if x < 0.5 then 'a' else 'z') values
"aazaaz"
</pre></div>
          </section>
          <section>
            <h2>Type Theory: Abstraction and Application</h2>
<div class='terminal'><pre>
λ> :t (\x -> if x < 0.5 then 'a' else 'z')
(\x -> if x < 0.5 then 'a' else 'z') :: (Ord a, Fractional a) => a -> Char

λ> (\x -> if x < 0.5 then 'a' else 'z') 0.2
'a'

λ> (\x -> if x < 0.5 then 'a' else 'z') 0.5
'z'
</pre></div>
          </section>
          <section>
<div class='terminal'><pre>
λ> capitalOf = Map.fromList [("Arrakeen", "Arrakis")]
λ> Map.lookup "France" capitals
Nothing

λ> Map.lookup "Arrakis" capitals
Just "Arrakeen"
</pre></div>
          </section>
          <section>
<pre style='font-size:0.95em;'><code class='stretch haskell'>type Graph k e = Map k (Map k e)

getEdge :: (Ord k) => k -> k -> Graph k e -> Maybe e
getEdge head tail g =
  case Map.lookup head g of
    Maybe g' => case Map.lookup tail g' of
                  Maybe edge => edge
                  Nothing    => Nothing
    Nothing => Nothing
</code></pre>
          </section>
          <section>
<pre style='font-size:0.95em;'><code class='stretch haskell'>type Graph k e = Map k (Map k e)

getEdge :: (Ord k) => k -> k -> Graph k e -> Maybe e
getEdge head tail g = Map.lookup head g >>= Map.lookup tail
</code></pre>
          </section>
          <section>
<pre style='font-size:1em;'><code class='stretch haskell'>class Monad m where
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b        -> m b
  return :: a                 -> m a
  fail   :: String -> m a
</code></pre>
          </section>
          <section>
            <img src='img/lyah.png' alt='lyah'/>
            <p>Miran Lipovaca. <b>Learn You a Haskell for Great Good!</b> (<a href='http://learnyouahaskell.com'>http://learnyouahaskell.com</a>), No Starch Press, 2011.</p>
          </section>
          <section>
            <img width='900px' src='img/category-in-context.jpg' alt='context'/>
            <p>Emily Riehl (<a href='https://twitter.com/emilyriehl'>@emilyriehl</a>), <b>Category Theory in Context</b>, Dover, 2016.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Many-Valued Logics</h2>
          </section>
          <section>
            <h2>Bivalence (0th order fuzziness)</h2>
            \[Truth \in \{False, True\}.\]
            <br/>
            \[Truth \in \{F, T\}.\]
            <br/>
            \[Truth \in \{\bot, \top\}.\]
            <br/>
            \[\{Theory\ x: True\}.\]
          </section>
          <section>
            <h2>A few properties</h2>
            <p>Conjunction and disjunction are commutative, idempotent:</p>
            \[a \land b \equiv b \land a, a \lor b \equiv b \lor a.\]
            \[a \land a \equiv a, b \lor b \equiv b.\]
            <br/>
            <p>De Morgan laws:</p>
            \[a \land b \equiv \neg (\neg a \lor \neg b).\]
            \[a \lor b \equiv \neg (\neg a \land \neg b).\]
            <br/>
            <p>Negation is involutive: \(\neg \neg x \equiv x\).</p>
          </section>
          <section>
            <h2>1st order fuzziness</h2>
            \[\{x \in \mathbb{R}: 0 \leq x \leq 1\}.\]
            <br/>
            \[\{Theory\ x: 0.72918\}.\]
            <br/>
            <p>Viruses are alive: 0.8.</p>
            <p>Wolves prey on rabbits: 0.06.</p>
            <p>1. Nf3 is a good chess opening: 0.94.</p>
            <p>X speaks Korean: 0.86.</p>
            <p>Quebec French = French: 0.95.</p>
          </section>
          <section>
            <h2>Many-valued logic &amp; connectives</h2>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Connective</th>
                <th>Łukasiewicz</th>
                <th>Gödel-Dummett</th>
                <th>Product</th>
              </tr>
              <tr>
                <td>\(x \land y\)</td>
                <td>\(max(0, x + y - 1)\)</td>
                <td>\(min(x, y)\)</td>
                <td>\(x \times y\)</td>
              </tr>
              <tr>
                <td>\(x \lor y\)</td>
                <td>\(min(1, x + y)\)</td>
                <td>\(max(x, y)\)</td>
                <td>\(x + y - x\times y\)</td>
              </tr>
              <tr>
                <td>\(x \Rightarrow y\)</td>
                <td>\(min(1, 1 - x + y)\)</td>
                <td>1 if \(x \leq y\) else \(y\)</td>
                <td>1 if \(x \leq y\) else \(y/x\)</td>
              </tr>
              <tr>
                <td>\(\neg x\)</td>
                <td>\(1 - x\)</td>
                <td>0 if \(x > 0\) else 1</td>
                <td>0 if \(x > 0\) else 1</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Three core fuzzy logics?</h2>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>Mostert–Shields’ theorem shows that a t-norm is continuous if and only if it
              can be built from the previous three ones by the construction of ordinal sum. In
              other words, a t-norm is continuous if and only if it is an ordinal sum of
              Łukasiewicz, Gödel and product t-norms.</p>
            </blockquote>
            <p>Flaminio et al. <i>Towards a probability theory for product logic: States, integral representation and reasoning</i>. doi: 10.1016/j.ijar.2017.11.003.</p>
          </section>
          <section>
            <h2>Properties</h2>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Property</th>
                <th>Łukasiewicz</th>
                <th>Gödel-Dummett</th>
                <th>Product</th>
              </tr>
              <tr>
                <td>Normal</td>
                <td>Yes!</td>
                <td>Yes!</td>
                <td>Yes!</td>
              </tr>
              <tr>
                <td>Idempotent \(\land, \lor\)</td>
                <td><font color='#CE0909'>Nay!</font></td>
                <td>Yes!</td>
                <td><font color='#CE0909'>Nay!</font></td>
              </tr>
              <tr>
                <td>Involutive \(\neg\)</td>
                <td>Yes!</td>
                <td><font color='#CE0909'>Nay!</font></td>
                <td><font color='#CE0909'>Nay!</font></td>
              </tr>
              <tr>
                <td>De Morgan laws</td>
                <td>Yes!</td>
                <td><font color='#CE0909'>Nay!</font></td>
                <td><font color='#CE0909'>Nay!</font></td>
              </tr>
            </table>
          </section>
          <section>
            <img src='img/book-mathfuzzy1.jpg' alt='mathfuzzy1'/>
            <p>Petr Cintula, Petr H. Jek, and Carles Noguera. <b>Handbook of Mathematical Fuzzy Logic Volume {1, 2}</b>, College Publications, 2011.</p>
            <p>Petr Cintula, Christian G. Fermueller, and Carles Noguera. <b>Handbook of Mathematical Fuzzy Logic Volume 3</b>, College Publications, 2015.</p>
          </section>
          <section>
            <img width='400px' src='img/book-fuzzymath.png' alt='mathfuzzy1'/>
            <p>Radim Belohlavek, Joseph W. Dauben, and George J. Klir. <b>Fuzzy Logic and Mathematics: A Historical Perspective</b>, Oxford University Press, 2017.</p>
          </section>
          <section>
            <h2>2nd order fuzziness</h2>
            <p>Interval:</p>
            \[\{\mathbb{x} \in \mathbb{R}^2: 0 \leq x_0 \leq x_1 \leq 1\}.\]
            <br/>
            \[\{Theory\ x: [0.6981, 0.73019]\}.\]
            <br/>
            <p>Generalized:</p>
            \[\{x \in \mathbb{R}: 0 \leq x \leq 1\} \mapsto \{y \in \mathbb{R}: 0 \leq y \leq 1\}.\]
          </section>
          <section>
            <h2>2nd order fuzziness</h2>
            \[\{\{Theory\ x: 0.25\}: 0.0\}.\]
            \[\{\{Theory\ x: 0.7071\}: 0.65\}.\]
            \[\{\{Theory\ x: 0.73\}: 0.86\}.\]
          </section>
          <section>
            <img src='img/book cover-mendel17.png' alt='mendel17'/>
            <p>Jerry M. Mendel. <b>Uncertain Rule-Based Fuzzy Systems 2nd edition</b>, Springer, 2017.</p>
          </section>
          <section>
            <h2>Pure logic</h2>
            <img src='img/preyon-log.png' alt='log'/>
          </section>
          <section>
            <h2>Probabilistic logic<br/>(à la Markov Logic Networks)</h2>
            <img src='img/preyon-prob.png' alt='prob'/>
          </section>
          <section>
            <h2>Fuzzy Logic</h2>
            <img src='img/preyon-fuzzy1.png' alt='f1'/>
          </section>
          <section>
            <h2>Fuzzy Logic</h2>
            <img src='img/preyon-fuzzy2.png' alt='f2'/>
          </section>
          <section>
            <img src='img/paper-fuzzy-tt.png' alt='fuzzy tt'/>
          </section>
          <section>
            <h2>What to do?</h2>
            <p>Implement fuzzy type theory, more specifically, a fuzzy CoC.</p>
            <p>Model truth as either bivalent OR fuzzy (OR fuzzy2?) to ensure 100% compatibility with existing systems.</p>
            <p>"Core" knowledge would remain bivalent (mostly maths, but also some scientific principles).</p>
            <p>Fuzzy fact could bring data into the mix.</p>
            <p>Would need to reevalute some sections of the knowledge base with new facts.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Higher-Order Probabilistic Programming</h2>
          </section>
          <section>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>[...] ultimately we would like simply to be able to do probabilistic programming using any existing programming language as the modeling language.</p>
            </blockquote>
            <p>From J-W van de Meent et al. <i>An Introduction to Probabilistic Programming</i>, arxiv:1809.10756, 2018.</p>
          </section>
          <section>
            <img src='img/paper-staton16.png' alt='staton16'/>
          </section>
          <section>
            <img src='img/article-category.png' alt='cat'/>
          </section>
          <section>
            <img src='img/article-lambda-prob.png' alt='lambda prob'/>
          </section>
          <section>
            <img src='img/probabilistic-lambda.png' alt='probabilistic lambda'/>
          </section>
          <section>
            <h2>Solid Implementations!</h2>
            <p><a href='https://github.com/probprog/anglican'>Anglican</a></p>
            <p><a href='https://github.com/TuringLang/Turing.jl'>Turing.jl</a></p>
            <p><a href='https://pyro.ai/'>Uber's Pyro</a></p>
          </section>
        </section>

        <section>
          <section>
            <h2>TLDR;</h2>
          </section>
          <section>
            <p><b>Mathematical reasoning is difficult: we need to find the correct sequence of rules to reach a goal.</b></p>
            <p><b>...but it provides a lot of context to knowledge and allow the formation of large databases of interconnected knowledge.</b></p>
            <p><b>First-order logic is simple, expressive, and can encode a great deal of mathematics.</b></p>
            <p><b>Programs are proofs! Type theory can form the basis for flexible function programming languages capable of formalizing mathematics and performing quantification over arbitrary structures.</b></p>
          </section>
          <section>
            <p><b>Many-valued logics are one way to inject more flexibility into rich logics.</b></p>
            <p><b>Higher-order probabilistic programming allows us to define probabilistic over any functions.</b></p>
            <p><b>For ecology/evolution, we need both the ability of a rich logic to formalize ideas and a framework to make it more flexible.</b></p>
            <p><b>What we need now is to develop the tools and learn how to encode ecological knowledge with them.</b></p>
          </section>
        </section>

      </div>
    </div>

    <script src='reveal.js-3.8.0/js/reveal.js'></script>
    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        width: '80%',
        height: '100%',
        margin: 0,
        minScale: 1,
        maxScale: 1,
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: '',

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        dependencies: [
          { src: 'reveal.js-3.8.0/plugin/highlight/highlight.js', async: true }
        <!--  { src: 'plugin/math/math.js', async: true } -->
        ]
      });
    </script>
    <script type='text/javascript' src='../../js/bower/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
