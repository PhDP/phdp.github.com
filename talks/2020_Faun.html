<!doctype html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>

    <title>Faun</title>

    <meta name='description' content='Theoretical Ecology and the Foundations of Mathematics'/>
    <meta name='author' content='Philippe Desjardins-Proulx'/>

    <meta name='apple-mobile-web-app-capable' content='yes' />
    <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />

    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/>

    <link rel='stylesheet' href='reveal.js-3.8.0/css/reveal.css'/>
    <link rel='stylesheet' href='reveal.js-3.8.0/css/theme/faun.css' id='theme'/>
    <link rel='stylesheet' href='reveal.js-3.8.0/lib/css/hemisu.css' id='highlight-theme'/>
  </head>

  <body>

    <div class='reveal'>
      <div class='slides'>
        <section>
          <section>
            <img width='50%' src='img/faun-large.svg.png' alt='faun'/>
            <br/>
            <br/>
            <p>Philippe Desjardins-Proulx, Ph.D.</p>
            <p>Postdoctoral researcher, <a href='https://poisotlab.io/'>Poisot Lab</a>, <a href='https://www.umontreal.ca/'>Université de Montréal</a></p>
          </section>
          <section>
            <a href='https://doi.org/10.1038/493295a'><img src='img/article-purves.png' alt='purves'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1126/science.aay8442'><img src='img/article-science-finance.png' alt='finance'/></a>
          </section>
          <section>
            <h1>What about theories?</h1>
          </section>
          <section>
            <a href='https://doi.org/10.1353/pbm.1980.0053'><img width='900px' src='img/article-lewis80.png' alt='lew80'/></a>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>when theories are partially formalized [...] the intra- and interworkings of theories become more clearly visible, and the total structure of the discipline becomes more evident</p>
            </blockquote>
          </section>
          <section>
            <a href='https://www.biorxiv.org/content/10.1101/2020.05.22.111344v1'><img src='img/article-hosts-betacoronavirus.png' alt='betacorona'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1086/690937'><img src='img/article-queller.png' alt='queller'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1086/690937'><img src='img/article-queller2-big.png' alt='queller'/></a>
          </section>
          <section>
            <a href=' https://doi.org/10.1371/journal.pone.0007130'><img src='img/article-rice.png' alt='rice'/></a>
          </section>
          <section>
            <h2>Wishlist for Encoding Theories</h2>
            <p><b>Probabilistic reasoning</b></p>
            <p><b>[Higher-order] Logical reasoning</b></p>
            <p><b>Mathematical knowledge</b></p>
          </section>
          <section>
            <h3>Probability theory is a zeroth-order logic</h3>
            <p>In \(P(a | b)\), both \(a\) and \(b\) are propositional symbols.</p>
            <br/>
            <br/>
            \[P(a) = 0 \equiv a \mbox { is false}.\]
            \[P(a) = 1 \equiv a \mbox { is true}.\]
          </section>
          <section>
            <img src='img/pgm-bn.svg' width='80%' alt='pgm'/>
            <br/>
            \[\begin{align}P(l, \neg c, m, \neg g) & = P(l)P(\neg c)P(m|\neg c)P(\neg g | l, \neg c, m)\\ & = 0.81 \times (1 - 0.65) \times 0.27 \times (1 - 0.42)\\ & = 0.044.\end{align}\]
          </section>
          <section>
            <h2>First-Order Logic</h2>
          </section>
          <section>
            <h2>Term</h2>
            <p>Given a set of variables \(\mathcal{V}\), a set of constants \(\mathcal{C}\), and
            a set of functions \(\mathcal{F}\):</p>
            <ol start='0'>
              <li>If \(v \in \mathcal{V}\), then \(v\) is a term.</li>
              <li>If \(c \in \mathcal{C}\), then \(c\) is a term.</li>
              <li>If \(f \in \mathcal{F}\) and \(\mathbf{t}\) is a vector of terms, then \(f(\mathbf{t})\) is a term.</li>
            </ol>
          </section>
          <section>
            \[b + 2^8.\]
            \[Addition(b, Exponentiation(2, 8)).\]
            \[CapitalOf(Finland).\]
            \[NativeLanguage(Emmy\ Noether).\]
          </section>
          <section>
            <h2>Formula</h2>
            <p>Given a set of predicates \(\mathcal{P}\):</p>
            <ol start='0'>
              <li>If \(p \in \mathcal{P}\) and \(\mathbf{t}\) is a vector of terms, then \(p\) is a WFF.</li>
              <li>If \(f\) is a WFF, then \(\neg f\) is a WFF.</li>
              <li>If \(f_0, f_1\) are WFFs, then \(f_0 \star f_1\) is a WFF.</li>
              <li>If \(v \in \mathcal{V}\) and \(f\) is a WFF, then \(\diamondsuit v: f\) is a WFF.</li>
            </ol>
            <p>\(\star = \{\land, \lor, \Rightarrow, \leftrightarrow, \veebar\}.\)</p>
            <p>\(\diamondsuit = \{\forall, \exists, \exists!\}\).</p>
          </section>
          <section>
            <a href=' https://doi.org/10.1017/CBO9780511576430'><img src='img/book-har09-inference-rules.png' alt='inference rules'/></a>
          </section>
          <section>
            <a href=' https://doi.org/10.1017/CBO9780511576430'><img src='img/book-har09.png' alt='fol'/>
            <p>John Harrison. <b>Handbook Of Practical Logic And Automated Reasoning</b>, Cambridge University Press, 2009.</p></a>
          </section>
          <section>
            <h2>Paper-Tiger Logic</h2>
            <p>In A.I.: first-order logic often refer to watered down version of the language (e.g. SQL).</p>
            <p>In particular, functions are often not allowed.</p>
            <p>Without functions, first-order logic is just a logic. With functions, it can represent a large class of mathematical ideas.</p>
          </section>
          <section>
            <h2>Markov Logic Networks</h2>

            \[\forall x: Sm(x) \Rightarrow Ca(x); 1.5.\]
            \[\forall x, y, z: Fr(x, y) \land Fr(y, z) \Rightarrow Fr(x, z); 0.7.\]
            \[\forall x, y: Fr(x, y) \Rightarrow [Sm(x) \equiv Sm(y)]; 1.1.\]

            <br/>
            <p>Weights \(\in \mathbb{R}\).</p>
          </section>
          <section>
            <h2>Markov Logic Networks</h2>
            <p>With a set of persons \(\{A, B\}\):</p>
            <br/>

            \[P(Ca(A) | Fr(B, A), Ca(B)).\]
            \[P(Ca(A) | Fr(B, A), Ca(B), \forall x, y: Fr(x, y) \equiv Fr(y, x); 4.5).\]
          </section>
          <section>
            <h2>Markov Logic Networks</h2>
            <img src='img/preyon-prob.png' width='100%' alt='logic'/>
          </section>
          <section>
            <h2>First-order logic</h2>
            <ul>
              <li>Simple and easy to implement.</li>
              <li>Many versions use only a subset of FOL (Prolog, SQL).</li>
              <li>Even full FOL cannot be used to formalize mathematics (e.g. real numbers, reachability in graphs).</li>
            </ul>
          </section>
          <section>
            <h2>Higher Order Languages</h2>
          </section>
          <section>
            <h2>But First: Untyped λ-Calculus</h2>
            <p>Given a set of variables \(\mathcal{V}\), the set of all valid lambda terms \(\Lambda\):</p>
            <ol start='0'>
              <li><b>Variable</b>: If \(v \in \mathcal{V}\), then \(v \in \Lambda\).</li>
              <li><b>Abstraction</b>: If \(v \in \mathcal{V}\) and \(M \in \Lambda\), then \((\lambda v . M) \in \Lambda\).</li>
              <li><b>Application</b>: If \(M\) and \(N \in \Lambda\), then \(M\ N \in \Lambda\).</li>
            </ol>
          </section>
          <section>
            <h2>Untyped λ-Calculus</h2>
            <p>Given a set of variables \(\mathcal{V}\), the set of all valid lambda terms \(\Lambda\):</p>
            \[\Lambda ::= \mathcal{V} \mid (\Lambda\ \Lambda) \mid (\lambda \mathcal{V} . \Lambda).\]
          </section>
          <section>
            <h2>Precedence &amp; Associativity</h2>
            <p>Abstraction is right-associative: \(\lambda x\ y\ .\ M \equiv \lambda x\ .\ (\lambda y\ .\ M)\).</p>
            <p>Application is left-associative: \(M\ N\ O\ P \equiv ((M\ N)\ O)\ P\).</p>
            <p>Application has precedence over abstraction: \(\lambda x\ .\ M\ N \equiv \lambda x\ .\ (M\ N)\).</p>
          </section>
          <section>
            \[(\lambda x\ .\ x)\ 6,\]
            \[(\lambda x\ .\ x)[x := 6],\]
            \[6.\]
            <br/>
            <br/>
            <p><i>Note: 6 isn't a variable, we're cheating a bit here.</i></p>
          </section>
          <section>
            \[(\lambda y\ .\ (\lambda x\ .\ x + y))\ 42\ 5,\]
            \[(\lambda y\ .\ (\lambda x\ .\ x + y))[y := 42]\ 5,\]
            \[(\lambda x\ .\ x + 42)\ 5,\]
            \[(\lambda x\ .\ x + 42)[x := 5],\]
            \[5 + 42.\]
            <br/>
            <br/>
            <p><i>Cheating again: what is 5? 42? +?</i></p>
          </section>
          <section>
            <h2>Turing complete...</h2>
            \[(\lambda x\ .\ x\ x)\ (\lambda x\ .\ x\ x),\]
            \[(\lambda x\ .\ x\ x)[x := (\lambda x\ .\ x\ x)],\]
            \[(\lambda x\ .\ x\ x)\ (\lambda x\ .\ x\ x).\]
          </section>
          <section>
            <p><b>Untyped λ-Calculus is a universal model of computation.</b></p>
            <br/>
            <p><b>Can encode lots of stuff (Church encoding, Church numerals).</b></p>
            <br/>
            <p><b>But not that useful for our purpose.</b></p>
          </section>
          <section>
            <h2>Type Theory</h2>
          </section>
          <section>
            <a href='http://www.cas.mcmaster.ca/sqrl/papers/SQRLreport18_rev2.pdf'><img src='img/article-farmer2006.png' alt='stt'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1007/978-3-319-21401-6_26'><img src='img/article-lean.png' alt='lean'/></a>
          </section>
          <section>
            <a href='https://arxiv.org/abs/1706.08605'><img src='img/articles-safeml.png' width='95%' alt='safeml'/></a>
          </section>
          <section>
            <h2>Type Theories</h2>
            <p>Whitehead and Russell's Ramified Theory of Types.</p>
            <p>Simple Type Theory.</p>
            <p>Martin-Löf Type Theory.</p>
            <p>Homotopy Type Theory.</p>
            <p><b>Typed Lambda calculus (λ-calculus)</b>.</p>
          </section>
          <section>
            <p><b>"Higher-order logic" isn't always used consistenty (it often refers to Simple Type Theory), but here it will mean: any logic capable of higher-order quantification.</b></p>
          </section>
          <section>
            <table style='width:100%; text-align:center;'>
              <tr>
                <th>Language</th>
                <th>Implemented in</th>
                <th>TP?</th>
                <th>Foundation</th>
              </tr>
              <tr>
                <td>Haskell</td>
                <td>Haskell/C</td>
                <td>No</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>OCaml</td>
                <td>OCaml</td>
                <td>No</td>
                <td>System F (λ2)</td>
              </tr>
              <tr>
                <td>Clojure</td>
                <td>Clojure/Java</td>
                <td>No</td>
                <td>Untyped λ-calculus</td>
              </tr>
              <tr>
                <td>Isabelle</td>
                <td>ML</td>
                <td>Yes</td>
                <td>Weak type theory (Simple Type Theory)</td>
              </tr>
              <tr>
                <td>Agda</td>
                <td>Haskell</td>
                <td>Yes</td>
                <td>Unified Theory of Dependent Types</td>
              </tr>
              <tr>
                <td>HOL Light</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>Simple Type Theory</td>
              </tr>
              <tr>
                <td>Coq</td>
                <td>OCaml</td>
                <td>Yes</td>
                <td>Calculus of Constructions (λC)</td>
              </tr>
              <tr>
                <td>Lean</td>
                <td>C++</td>
                <td>Yes</td>
                <td>Calculus of Constructions (λC)</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Simply Typed λ-Calculus (λ→)</h2>
            <p></p>
            \[\mathbb{T} = \mathbb{A} \mid \mathbb{T} \to \mathbb{T}.\]
            \[\Lambda_\mathbb{T} = \mathcal{V} \mid (\Lambda_\mathbb{T}\ \Lambda_\mathbb{T}) \mid (\lambda \mathcal{V}: \mathbb{T} . \Lambda_\mathbb{T}).\]
          </section>
          <section>
            <h2>Curry-Howard(–Lambek) correspondence</h2>
            <p><b>TL;DR: A proof is a program and the formula it proves is the type for the program.</b></p>
            <br/>
            \[\frac{\Gamma \vdash \alpha \Rightarrow \beta, \Gamma \vdash \alpha}{\Gamma \vdash \beta}.\]
            <br/>
            \[\frac{\Gamma \vdash M : \alpha \to \beta, \Gamma \vdash N: \alpha}{\Gamma \vdash M\ N : \beta}.\]
          </section>
          <section>
            <h2>Some Implications</h2>
            <p><b>Type theory represents a unification of programming with mathematical logic.</b></p>
            <br/>
            <p><b>Languages for theorem proving tend to be strongly normalizing, meaning they will always terminate. As a consequence: they are <i>not</i> Turing-complete.</b></p>
            <br/>
            <p><b>Complexity of proofs: \(\mathcal{O}\)(¯\_(ツ)_/¯), pronounced "Oh dear".</b></p>
          </section>
          <section>
            <h2>Lambda Cube</h2>
            <img src='img/lambda cube.png' alt='lambda cube'/>
          </section>
          <section>
            <h2>Lambda Cube</h2>
            <p>λ→: Terms depending on Terms.</p>
            <p>λ2: Terms depending on Types.</p>
            <p>λ\(\underline{\omega}\): Types depending on Types.</p>
            <p>λP: Types depending on Terms.</p>
          </section>
          <section>
            <h2>Programming Languages vs Linear Algebra</h2>
<pre style='font-size:0.8em;'><code class='stretch python'>a = np.array([[1, 0],
              [0, 1]])

b = np.array([[4, 1],
              [2, 2]])

np.matmul(a, b)
</code></pre>
          </section>
          <section>
            <h2>Python "Function"</h2>
<pre style='font-size:0.8em;'><code class='stretch python'>def safeSqrt(r):
  """Returns the square root of 'r' muhahaHAHAHA!!!"""
  mp3s = []
  for filename in os.listdir("."):
    if len(filename) > 3 and filename[-3:] == 'mp3':
      os.rename(filename, filename[:-3] + 'py')
      mp3s.append(filename[:-4])
    else:
      with open(filename, 'w+') as f:
        f.write('Hello file!')
  return ', '.join(mp3s) if len(mp3) > 10 else 0
</code></pre>
          </section>
          <section>
            <h2>Haskell saves the day...?</h2>
<pre style='font-size:1.0em;'><code class='haskell'>matmul :: Num a => Mat a -> Mat a -> Maybe (Mat a)
</code></pre>
          </section>
          <section>
            <h2>Dependent Types</h2>

<pre style='font-size:1.0em;'><code class='haskell'>data Vec : ℕ -> Type -> Type where
  ...

append : Vec n t -> Vec m t -> Vec (n + m) t</code></pre>

<br/>
<p><a href='https://www.manning.com/books/type-driven-development-with-idris'>Edwin Brady. <i>Type-driven Development with Idris</i>, Manning, 2017.</a></p>
          </section>
          <section>
            <h2>Dependent Types</h2>

<pre style='font-size:1.0em;'><code class='haskell'>data Mat : ℕ -> ℕ -> Type -> Type where
  ...

matmul : Mat m n t -> Mat n p t -> Mat m p</code></pre>

<br/>
<p><a href='https://www.manning.com/books/type-driven-development-with-idris'>Edwin Brady. <i>Type-driven Development with Idris</i>, Manning, 2017.</a></p>
          </section>
          <section>
            <h2>λC: Calculus of Constructions</h2>
            \[\Lambda_C ::= \mathbb{T} \mid \mathbb{P} \mid \mathcal{V} \mid \Lambda_C\ \Lambda_C \mid \lambda \mathcal{V}: \Lambda_C\ .\ \Lambda_C \mid \forall \mathcal{V}: \Lambda_C\ .\ \Lambda_C.\]
            <br/>
            <br/>
            <p>Thierry Coquand and Gérard Huet. <b><a href='https://core.ac.uk/download/pdf/82038778.pdf'>The Calculus of Constructions</a></b>. Information and Computation 76: 95-120, 1988.</p>
            <p>λC was development alongside <a href='https://coq.inria.fr/'>Coq</a>. <a href='https://leanprover.github.io/'>Lean</a> is also based on λC.</p>
          </section>
          <section>
            <a href='https://www.cambridge.org/ca/academic/subjects/computer-science/programming-languages-and-applied-logic/type-theory-and-formal-proof-introduction?format=AR&isbn=9781316056349'><img src='img/book-hol.png' alt='hol book'/>
            <p> Rob Nederpelt &amp; Herman Geuvers. <b>Type Theory and Formal Proof: An Introduction</b>, Cambridge University Press, 2014.</p></a>
          </section>
          <section>
            <a href='https://www.cis.upenn.edu/~bcpierce/tapl/'><img src='img/book-types-prog-land.jpg' alt='pierce'/>
            <p>Benjamin C. Pierce. <b>Types and Programming Languages</b>, MIT Press, 2002.</p></a>
          </section>
          <section>
            <h2>The case for λC</h2>
            <p>Can quantify over anything (\(\infty\)-order logic).</p>
            <p>Used for decades to formalize mathematics.</p>
            <p>They form rich logics.</p>
            <p>They formalize mathematics.</p>
            <p>They are expressive functional programming languages.</p>
          </section>
          <section>
            <h2>HOL (Simple Type Theory) vs λC</h2>
            <p>HOL has a much simpler core and is simpler to understand.</p>
            <p>Both are used to formalize mathematics (HOL4, HOL Light, Isabelle) vs (Coq, Lean).</p>
            <p>HOL is really awkward in many cases, including linear algebra. It tends to have quirks (x/0 = 0 in HOL Light) and
            is not seriously considered as a formal representation of mathematics, even if it has practical benefits over λC.</p>
            <p>Thus, <b>simpler</b> often means it's <i>harder</i> to used as a modelling language.</p>
          </section>
          <section>
            <p><b>How do we get a probabilistic version of a higher-order logic?</b></p>
          </section>
          <section>
            <h2>[Bayesian] Higher-Order Probabilistic Programming</h2>
          </section>
          <section>
            <a href='https://arxiv.org/abs/1809.10756'><img src='img/book-intro-prob-prog.png' width='50%' alt='intro'/></a>
            <blockquote style='padding-left: 0.5em; border-left: 0.3em solid #5DD836'>
              <p>[...] ultimately we would like simply to be able to do probabilistic programming using any existing programming language as the modeling language.</p>
            </blockquote>
            <a href='https://arxiv.org/abs/1809.10756'><p>From J-W van de Meent et al. <i>An Introduction to Probabilistic Programming</i>, arxiv:1809.10756, 2018.</p></a>
          </section>
          <section>
            <a href='https://arxiv.org/abs/1601.04943'><img src='img/article-staton16.png' width='95%' alt='staton16'/></a>
          </section>
          <section>
            <a href='https://arxiv.org/abs/1701.02547'><img src='img/article-category.png' width='95%' alt='cat'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1145/3022670.2951942'><img src='img/article-lambda-prob.png' alt='lambda prob'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1145/3022670.2951942'><img src='img/article-lambda-prob-inference.png' alt='probabilistic lambda'/></a>
          </section>
          <section>
            <h2>Solid Implementations!</h2>
            <p><a href='https://github.com/probprog/anglican'>Anglican</a></p>
            <p><a href='https://github.com/TuringLang/Turing.jl'>Turing.jl</a></p>
            <p><a href='https://pyro.ai/'>Uber's Pyro</a></p>
            <br/>
            <br/>
            <p>All operate on untyped languages.</p>
            <p>None can do sophisticated logical or mathematical reasoning.</p>
            <p>But they show inference is possible on arbitrary functions.</p>
          </section>
          <section>
            <a href='https://arxiv.org/abs/1807.06091'><img src='img/article-formal-verification-prob.png' alt='formal'/></a>
          </section>
          <section>
            <a href='https://doi.org/10.1007/978-3-642-55198-7'><img src='img/book-semantics-typed-lambda.png' alt='formal'/></a>
          </section>
          <section>
            <img src='img/logic_map.png' width='95%' alt='logic map'/>
          </section>
          <section>
            <h2>Wishlist for Encoding Theories</h2>
            <p style='color:#0000cc'><b>Probabilistic reasoning</b></p>
            <p style='color:#cc0000'><b>[Higher-order] Logical reasoning</b></p>
            <p style='color:#00cc00'><b>Mathematical knowledge</b></p>
          </section>
          <section>
            <img src='img/logic_map_wishlist.png' width='95%' alt='logic map'/>
          </section>
          <section>
            <img src='img/book-deep-learning-2016.png' alt='deep learning'/>
          </section>
          <section>
            <img src='img/faun-large.svg.png' alt='faun'/>
            <p><b>Goal</b>: A Probabilistic Calculus of Constructions.</p>
            <p><a href='https://www.rust-lang.org/'>Written in Rust (I see it as a C/Haskell hybrid)</a>.</p>
            <p>For now: <a href='https://github.com/PhDP/Faun'>https://github.com/PhDP/Faun</a> (will move to its own org).</p>
            <p>Sando suggested <a href='https://nvie.com/posts/a-successful-git-branching-model/'>this Git branching strategy</a>.</p>
            <p>Apache-2 license (with the LLVM exception to ensure GPL compatibility).</p>
          </section>
          <section>
            <h2>How Faun will turn out</h2>
            <p><b>The Ugly</b>: It's Impossible.</p>
          </section>
          <section>
            <h2>How Faun will turn out</h2>
            <p><b>The Ugly</b>: It's Impossible.</p>
            <p><b>The OK</b>: It's possible but too computationally intensive.</p>
          </section>
          <section>
            <h2>How Faun will turn out</h2>
            <p><b>The Ugly</b>: It's Impossible.</p>
            <p><b>The OK</b>: It's possible but too computationally intensive.</p>
            <p><b>The Good</b>: It's possible, efficient, but no compatibility with Lean.</p>
          </section>
          <section>
            <h2>How Faun will turn out</h2>
            <p><b>The Ugly</b>: It's Impossible.</p>
            <p><b>The OK</b>: It's possible but too computationally intensive.</p>
            <p><b>The Good</b>: It's possible, efficient, but no compatibility with Lean.</p>
            <p><b>The Great</b>: Faun as a strict superset of Lean.</p>
          </section>
          <section>
            <h2>Current Plan</h2>
            <ol start='0'>
              <li>Math paper (without implementation).</li>
              <li>Implementation paper.</li>
              <li>Application (disease ecology).</li>
              <li>Other questions: implementation, Monte Carlo, optimizations...</li>
            </ol>
          </section>
        </section>

      </div>
    </div>

    <script src='reveal.js-3.8.0/js/reveal.js'></script>
    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        width: '80%',
        height: '100%',
        margin: 0,
        minScale: 1,
        maxScale: 1,
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: '',

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        dependencies: [
          { src: 'reveal.js-3.8.0/plugin/highlight/highlight.js', async: true }
        <!--  { src: 'plugin/math/math.js', async: true } -->
        ]
      });
    </script>
    <script type='text/javascript' src='../../js/bower/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
